<?php

/*
 * Implements hook_menu().
 */
function mukurtu_taxonomy_records_menu() {
    $items = array();

    $items['taxonomy/term/%taxonomy_term/add-record'] = array(
        'title' => t('Add Record'),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('mukurtu_taxonomy_records_add_record_form', 2),
        'access callback' => 'mukurtu_taxonomy_records_add_record_form_access',
        'access arguments' => array(2),
        'type' => MENU_LOCAL_TASK,
        'weight' => 100,
    );

    $items['taxonomy/term/%taxonomy_term/remove-record/%node'] = array(
        'title' => t('Remove Record'),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('mukurtu_taxonomy_records_remove_record_form', 2, 4),
        'access callback' => 'mukurtu_taxonomy_records_remove_record_form_access',
        'access arguments' => array(2,4),
        'type' => MENU_LOCAL_TASK,
        'weight' => 100,
    );
    
    $items['dashboard/mukurtu-records'] = array(
        'title' => t('Mukurtu Records Configuration'),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('mukurtu_taxonomy_records_config_form'),
        'access callback' => 'mukurtu_taxonomy_records_config_form_access',
        'access arguments' => array(),
        'type' => MENU_LOCAL_TASK,
        'weight' => 100,
    );

    return $items;
}

// TODO: This form needs:
// 1: Pagination
// 2. Filters and/or autocomplete
function mukurtu_taxonomy_records_add_record_form($form, $form_state, $term) {
    // Check if the taxonomy is enabled for records
    if(!mukurtu_taxonomy_records_are_records_enabled($term)) {
        $form['records_not_enabled'] = array(
            '#markup' => t("Records are not enabled for the \"@vocab\" taxonomy.",
                           array('@vocab' => $term->vocabulary_machine_name)),
        );
        return $form;
    }

    $form['add_new_record_instructions'] = array(
        '#markup' => t("Select the type of new record for the \"@term\" term in the \"@vocab\" taxonomy:",
                       array('@term' => $term->name, '@vocab' => $term->vocabulary_machine_name)),
    );

    // For all the valid record types, makes links for the types the user has access to
    $record_list = mukurtu_taxonomy_records_entity_list();

    $new_record_links = array();
    foreach($record_list as $type => $bundles) {
        foreach($bundles as $bundle => $bundle_label) {           
            $add_path = "$type/add/$bundle/attach-record/{$term->tid}";
            if(drupal_valid_path($add_path)) {
                $new_record_links[] = l($bundle_label, $add_path);
            }
        }
    }
    $form['add_new_record'] = array(
        '#theme' => 'item_list',
        '#items' => $new_record_links,
    );

    // Existing Records
    $form['add_existing_record_instructions'] = array(
        '#markup' => t("Add an existing record for the \"@term\" term in the \"@vocab\" taxonomy:",
                       array('@term' => $term->name, '@vocab' => $term->vocabulary_machine_name)),
    );

    $header = array(
        'title' => array('data' => t('Title'), 'field' => 'n.title'),
        'thumbnail' => array('data' => t('Thumbnail')),
        'type' => array('data' => t('Type'), 'field' => 'n.type'),
        'author' => t('Author'),
        'status' => array('data' => t('Status'), 'field' => 'n.status'),
        'changed' => array('data' => t('Updated'), 'field' => 'n.changed', 'sort' => 'desc')
    );
    
    $options = array();

    // Get all available records
    $query = new EntityFieldQuery;
    $available_records = $query->entityCondition('entity_type', 'node')
                       ->entityCondition('bundle', $record_list['node'], 'IN')
                       ->execute();

    $record_nids = array();
    if(isset($available_records['node'])) {
        $record_nids = $available_records['node'];
    }

    // Get the list of terms that are already attached
    $emw_term = entity_metadata_wrapper('taxonomy_term', $term);
    $mukurtu_record_refs = array();
    foreach($emw_term->field_mukurtu_records->value() as $index => $record_ref) {
        $mukurtu_record_refs[] = $record_ref->nid;
    }
    
    foreach($record_nids as $nid => $value) {
        // Don't present already attached terms
        if(in_array($nid, $mukurtu_record_refs)) {
            continue;
        }
        
        $node = node_load($nid);
        $atom = scald_atom_load($node->field_media_asset[LANGUAGE_NONE][0]['sid']);

        $options[$node->nid] = array(
            'thumbnail' => scald_render($atom, 'sdl_library_item'),
            'title' => array(
                'data' => array(
                    '#type' => 'link',
                    '#title' => $node->title,
                    '#href' => 'node/' . $node->nid,
                ),
            ),
            'type' => check_plain(node_type_get_name($node)),
            'author' => theme('username', array('account' => $node)),
            'status' => $node->status ? t('published') : t('not published'),
            'changed' => format_date($node->changed, 'short'),
        );
    }

    $form['nodes'] = array(
      '#type' => 'tableselect',
      '#header' => $header,
      '#options' => $options,
      '#empty' => t('No records available.'),
    );
    
    $form['submit_button'] = array(
        '#type' => 'submit',
        '#value' => t('Add Selected'),
    );
    
    return $form;
}

function mukurtu_taxonomy_records_add_record_form_submit($form, &$form_state) {
    if(!isset($form_state['build_info']['args'][0])) {
        return;
    }
    
    $term = $form_state['build_info']['args'][0];

    // Add selected records
    $added = 0;
    if(isset($form_state['input']['nodes'])) {
        foreach($form_state['input']['nodes'] as $nid_to_add => $value) {
            if($value) {
                mukurtu_taxonomy_records_add_record_to_term($term, $nid_to_add);
                $added += 1;
            }
        }
    }

    if($added > 0) {
        drupal_set_message(t('Added the selected records'));
    }
}

function mukurtu_taxonomy_records_config_form($form, $form_state) {
    $vocabs = taxonomy_get_vocabularies();
    $options = array();
    $default_value = array();
    foreach($vocabs as $vocab) {
        $options[$vocab->vid] = $vocab->name;
        if(mukurtu_taxonomy_records_are_records_enabled_for_vocabulary($vocab)) {
            $default_value[] = $vocab->vid;
        }
    }

    $form['mukurtu_records']['enable_vocabs'] = array(
        '#type' => 'checkboxes',
        '#options' => $options,
        '#title' => t('Vocabularies Enabled for Mukurtu Records'),
        '#default_value' => $default_value
    );

    $form['submit_button'] = array(
        '#type' => 'submit',
        '#value' => t('Save configuration'),
    );
    
    return $form;
}

function mukurtu_taxonomy_records_config_form_submit($form, &$form_state) {
    foreach($form_state['values']['enable_vocabs'] as $index => $vid) {
        $vocab = taxonomy_vocabulary_load($index);
        if($vid && $vocab) {
                mukurtu_taxonomy_records_enable_records_for_vocabulary($vocab);
        } else {
            mukurtu_taxonomy_records_disable_records_for_vocabulary($vocab);
        }
    }
    drupal_set_message(t('Configuration saved'));
}

function mukurtu_taxonomy_records_enable_records_for_vocabulary($vocab) {
    // Check if vocab has the Mukurtu Records field
    $instances = field_info_instances('taxonomy_term', $vocab->machine_name);
    if(!isset($instances['field_mukurtu_records'])) {
        // If it doesn't, add the Mukurtu Records field to vocabulary
        $field_instance = array(
            'field_name' => 'field_mukurtu_records',
            'entity_type' => 'taxonomy_term',
            'label' => 'Records',
            'bundle' => $vocab->machine_name,
            'required' => FALSE,
            'display' => array(
                'default' => array(
                    'label' => 'hidden',
                    'module' => 'mukurtu_display_formatters',
                    'settings' => array(),
                    'type' => 'mukurtu_records_formatter',
                    'weight' => 0,
                ),
            ),
            'widget' => array(
                'active' => 1,
                'module' => 'options',
                'settings' => array(
                    'apply_chosen' => 0,
                ),
                'type' => 'options_select',
            ),
        );
        field_create_instance($field_instance);
    }
        
    // Enable CER for vocabulary <-> All record types
    mukurtu_taxonomy_records_enable_all_cer($vocab);
    /*    foreach(mukurtu_taxonomy_records_entity_list() as $type_label => $type) {
        foreach($type as $bundle_label => $bundle) {
            mukurtu_taxonomy_records_enable_cer('taxonomy_term', $vocab->machine_name, $type_label, $bundle_label);
        }
        }*/
}

function mukurtu_taxonomy_records_enable_all_cer($vocab) {
    foreach(mukurtu_taxonomy_records_entity_list() as $type_label => $type) {
        foreach($type as $bundle_label => $bundle) {
            mukurtu_taxonomy_records_enable_cer('taxonomy_term', $vocab->machine_name, $type_label, $bundle_label);
        }
    }
}

function mukurtu_taxonomy_records_disable_records_for_vocabulary($vocab) {
    if(mukurtu_taxonomy_records_are_records_enabled_for_vocabulary($vocab)) {
        foreach(mukurtu_taxonomy_records_entity_list() as $type_label => $type) {
            foreach($type as $bundle_label => $bundle) {
                mukurtu_taxonomy_records_disable_cer('taxonomy_term', $vocab->machine_name, $type_label, $bundle_label);
            }
        }
    }
}

function mukurtu_taxonomy_records_disable_cer($left_type, $left_bundle, $right_type, $right_bundle) {
    // All arguments are required non-null
    if(!$left_bundle || !$left_type || !$right_bundle || !$right_type) {
        return;
    }
    $left_field = 'field_mukurtu_records';
    if($left_type != 'taxonomy_term') {
        $left_field = 'field_mukurtu_terms';
    }

    $right_field = 'field_mukurtu_records';
    if($right_type != 'taxonomy_term') {
        $right_field = 'field_mukurtu_terms';
    }

    $left = "$left_type:$left_bundle:$left_field";
    $right = "$right_type:$right_bundle:$right_field";
    $identifier = "$left*$right";
    
    // Find the CER
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'cer')
        ->propertyCondition('identifier', $identifier)
        ->addMetaData('account', user_load(1));
    $result = $query->execute();

    // Delete the CER
    if(isset($result['cer'])) {
        foreach($result['cer'] as $cer) {
            entity_delete('cer', $cer->pid);
        }
    }
}

function mukurtu_taxonomy_records_enable_cer($left_type, $left_bundle, $right_type, $right_bundle) {
    // All arguments are required non-null
    if(!$left_bundle || !$left_type || !$right_bundle || !$right_type) {
        return;
    }

    $left_field = 'field_mukurtu_records';
    if($left_type != 'taxonomy_term') {
        $left_field = 'field_mukurtu_terms';
    }

    $right_field = 'field_mukurtu_records';
    if($right_type != 'taxonomy_term') {
        $right_field = 'field_mukurtu_terms';
    }

    $left = "$left_type:$left_bundle:$left_field";
    $right = "$right_type:$right_bundle:$right_field";
    $identifier = "$left*$right";

    if(!mukurtu_taxonomy_records_cer_exists($identifier)) {
        $cer = entity_create('cer', array('identifier' => $identifier));
        $cer_emw = entity_metadata_wrapper('cer', $cer);
        $cer_emw->cer_bidirectional = TRUE;
        $cer_emw->cer_enabled = TRUE;
        $cer_emw->cer_weight = 0;
        $cer_emw->cer_left = $left;
        $cer_emw->cer_right = $right;
        $cer_emw->save();
    }
}

function mukurtu_taxonomy_records_cer_exists($identifier) {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'cer')
        ->propertyCondition('identifier', $identifier)
        ->addMetaData('account', user_load(1));

    $result = $query->execute();

    if(isset($result['cer']) && count($result['cer']) > 0) {
        return TRUE;
    }
    return FALSE;
}

function mukurtu_taxonomy_records_config_form_access() {
    return user_access('administer taxonomy');
}

function mukurtu_taxonomy_records_add_record_form_access($term) {
    // If the term is records enabled
    if(mukurtu_taxonomy_records_are_records_enabled($term)) {
        // Allow anybody who can edit a taxonomy to add records to terms in that vocabulary
        return user_access("edit terms in {$term->vid}") || user_access('administer taxonomy');
    }
    return FALSE;
}

function mukurtu_taxonomy_records_remove_record_form($form, $form_state, $term, $record) {
    $question = t("Remove the record \"@record\" from term \"@term\"?", array('@record' => $record->title, '@term' => $term->name, '@vocab' => $term->vocabulary_machine_name));
    
    $description = t("Are you sure you want to detach the record \"@record\" currently attached to the \"@term\" term in the \"@vocab\" taxonomy? This will not delete the record.", array('@record' => $record->title, '@term' => $term->name, '@vocab' => $term->vocabulary_machine_name));
    return confirm_form($form, $question, drupal_get_destination(), $description);
}

function mukurtu_taxonomy_records_remove_record_form_access($term, $record) {
    // To reach the form to remove a record, a user must:
    // 1. Term must be records enabled
    // 2. Have permission to edit the record
    // 3. Have permission to edit the taxonomy
    if(mukurtu_taxonomy_records_are_records_enabled($term) && node_access('update', $record)) {
        return user_access("edit terms in {$term->vid}") || user_access('administer taxonomy');
    }
    return FALSE;
}

function mukurtu_taxonomy_records_remove_record_form_submit($form, $form_state) {
    if(isset($form_state['build_info']['args'][0])) {
        $term = $form_state['build_info']['args'][0];
    }

    if(isset($form_state['build_info']['args'][1])) {
        $record = $form_state['build_info']['args'][1];
    }

    if($term && $record) {
        mukurtu_taxonomy_records_remove_record_from_term($term, $record->nid);
    }
}

// Remove the reference to record_id from the term. CER will take care of the record to term reference.
function mukurtu_taxonomy_records_remove_record_from_term($term, $record_id) {
    $emw_term = entity_metadata_wrapper('taxonomy_term', $term);
    $mukurtu_record_refs = array();
    foreach($emw_term->field_mukurtu_records->value() as $index => $record_ref) {
        $mukurtu_record_refs[] = $record_ref->nid;
    }

    $key = array_search($record_id, $mukurtu_record_refs);
    if($key !== FALSE) {
        unset($mukurtu_record_refs[$key]);
        $emw_term->field_mukurtu_records->set($mukurtu_record_refs);
        $emw_term->save();
    }
}

function mukurtu_taxonomy_records_add_record_to_term($term, $record_id) {
    // Make sure CER is enabled
    mukurtu_taxonomy_records_enable_all_cer($vocab);

    // Add the reference
    $emw_term = entity_metadata_wrapper('taxonomy_term', $term);
    $mukurtu_record_refs = array();
    foreach($emw_term->field_mukurtu_records->value() as $index => $record_ref) {
        $mukurtu_record_refs[] = $record_ref->nid;
    }

    $mukurtu_record_refs[] = $record_id;
    $emw_term->field_mukurtu_records->set($mukurtu_record_refs);
    $emw_term->save();
}

function mukurtu_taxonomy_records_menu_alter(&$items) {
    $items['taxonomy/term/%taxonomy_term']['page callback'] = 'mukurtu_taxonomy_records_taxonomy_term_page';
    unset($items['taxonomy/term/%taxonomy_term']['file']);
}

function mukurtu_taxonomy_records_taxonomy_term_page($term) {
    // Terms might still have records data after records are disabled. Don't display them if not enabled.
    if(!mukurtu_taxonomy_records_are_records_enabled($term) && isset($term->field_mukurtu_records[LANGUAGE_NONE])) {
        unset($term->field_mukurtu_records[LANGUAGE_NONE]);
    }
    module_load_include('inc', 'taxonomy', 'taxonomy.pages');
    $build = taxonomy_term_page($term);

    if(isset($term->field_mukurtu_records) && !empty($term->field_mukurtu_records[LANGUAGE_NONE])){
        if(isset($build['nodes'])) {
            unset($build['nodes']);
        }
        if(isset($build['pager'])) {
            unset($build['pager']);
        }
    }
    return $build;
}

/*
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function mukurtu_taxonomy_records_form_node_form_alter(&$form, &$form_state, $form_id) {   
    if(isset($form_state['node']) && mukurtu_taxonomy_records_is_record($form_state['node'])) {
        // Check if we are attaching this record to a taxonomy term
        $action = arg(3);
        $tid = arg(4);
        if(isset($action) && isset($tid)) {
            if($action == 'attach-record') {
                if(isset($form['field_mukurtu_terms'][LANGUAGE_NONE]['#default_value'])) {
                    // Make sure CER is enabled
                    mukurtu_taxonomy_records_enable_all_cer($vocab);

                    // Put the reference in the form
                    $added = FALSE;
                    foreach($form['field_mukurtu_terms'][LANGUAGE_NONE]['#default_value'] as $selected_term) {
                        if($selected_term == $tid) {
                            $added = TRUE;
                        }
                    }
                    if(!$added) {
                        $form['field_mukurtu_terms'][LANGUAGE_NONE]['#default_value'][] = $tid;
                    }
                }
            }                    
        }
        
        // Hide node/media aggregate fields when editing. Those are set programmatically.
        $form['field_node_aggregate']['#access'] = FALSE;
        $form['field_media_aggregate']['#access'] = FALSE;

        // Hide the term field. We want users to use the 'add record' interface.
        $form['field_mukurtu_terms']['#access'] = FALSE;
    }
}

function mukurtu_taxonomy_records_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
    // Hide record field from term form when editing. We want users to use the 'add record' interface.
    if(isset($form['field_mukurtu_records'])) {
        $form['field_mukurtu_records']['#access'] = FALSE;
    }
}

/*
 * Implements hook_entity_update().
 */
function mukurtu_taxonomy_records_entity_update($entity, $type) {
    if($type == 'node') {
        $taxonomy_fields = field_read_fields(array('type' => 'taxonomy_term_reference'));
        $emw_node = entity_metadata_wrapper('node', $entity);
        $emw_node_original = entity_metadata_wrapper('node', $entity->original);
        foreach($taxonomy_fields as $taxonomy_field) {
            if(isset($entity->{$taxonomy_field['field_name']})) {
                $new = array();
                $old = array();
                // Get the new taxonomy refs
                foreach($emw_node->{$taxonomy_field['field_name']}->value() as $index => $ref) {
                    $new[] = $ref->tid;
                }               

                // Get the old taxonomy refs
                foreach($emw_node_original->{$taxonomy_field['field_name']}->value() as $index => $ref) {
                    $old[] = $ref->tid;
                }

                $new_old_diff = array_merge(array_diff($new, $old), array_diff($old, $new));

                // Update the record cache of all the terms that have been changed
                foreach($new_old_diff as $diff_tid) {
                    $diff_term = taxonomy_term_load($diff_tid);
                    if($diff_term) {
                        mukurtu_taxonomy_records_update_records_cache($diff_term);
                    }
                }
            }
        }
    }
}


/**
 * Updates the aggregate fields for attached records
 */
function mukurtu_taxonomy_records_update_records_cache($term) {
    // Get all the attached records
    $emw_term = entity_metadata_wrapper('taxonomy_term', $term);
    $mukurtu_record_refs = array();
    foreach($emw_term->field_mukurtu_records->value() as $index => $record_ref) {
        // Update the record's aggregate fields
        $emw_record = entity_metadata_wrapper('node', $record_ref);
        $emw_record->field_node_aggregate->set(mukurtu_taxonomy_records_get_aggregate($record_ref));
        $emw_record->save();
    }
}

/*
 * Implements hook_entity_presave().
 */
function mukurtu_taxonomy_records_entity_presave($entity, $type) {
    if($type == 'node') {
        if(mukurtu_taxonomy_records_is_record($entity)) {
            $emw_node = entity_metadata_wrapper('node', $entity);
            $emw_node->field_node_aggregate->set(mukurtu_taxonomy_records_get_aggregate($entity));
        }
    }
}

//function mukurtu_taxonomy_records_entity_view($entity, $type, $view_mode, $langcode) {
function mukurtu_taxonomy_records_entity_prepare_view($entities, $type, $langcode) {
    foreach($entities as $key => $entity) {
        //        mukurtu_taxonomy_records_rebuild_record($entities[$key]);
    }
    //    mukurtu_taxonomy_records_rebuild_record($entity);    
}

function mukurtu_taxonomy_records_get_aggregate($entity) {
    $aggregate = array();
    if(mukurtu_taxonomy_records_is_record($entity)) {
        $node_refs = array();
        foreach($entity->field_mukurtu_terms[LANGUAGE_NONE] as $term_ref) {
            $node_refs = array_merge(taxonomy_select_nodes($term_ref['target_id'], FALSE), $node_refs);
        }

        $node_refs = array_unique($node_refs);
        $self = array_search($entity->nid, $node_refs);
        if($self) {
            unset($node_refs[$self]);
        }

        foreach($node_refs as $nid) {
            // Don't aggregate other records
            $node = node_load($nid);
            if(!mukurtu_taxonomy_records_is_record($node)) {
                $aggregate[] = $nid;
            }
        }
    }
    return $aggregate;
}

// Returns if Mukurtu Taxonomy Records are enabled for a specific vocabulary
function mukurtu_taxonomy_records_are_records_enabled_for_vocabulary($vocab) {
    if(!isset($vocab->machine_name)) {
        return FALSE;
    }
    // To be enabled, the vocabulary needs:
    // 1. The 'field_mukurtu_records' field
    $instances = field_info_instances('taxonomy_term', $vocab->machine_name);
    if(isset($instances['field_mukurtu_records'])) {

        // 2. An enabled CER between the vocab and some other entity type
        // Find the CER, check both left/right
        foreach(array('cer_left', 'cer_right') as $cer_field) {
            $query = new EntityFieldQuery();
            $query->entityCondition('entity_type', 'cer')
                ->fieldCondition($cer_field, 'path', "taxonomy_term:{$vocab->machine_name}:field_mukurtu_records", '=')
                ->fieldCondition('cer_enabled', 'value', TRUE)
                ->addMetaData('account', user_load(1));
            
            $result = $query->execute();
            if(isset($result['cer']) && count($result['cer']) > 0) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

// Returns if Mukurtu Taxonomy Records are enabled for a specific term
function mukurtu_taxonomy_records_are_records_enabled($term) {
    if(isset($term->vid)) {
        $vocab = taxonomy_vocabulary_load($term->vid);
        return mukurtu_taxonomy_records_are_records_enabled_for_vocabulary($vocab);
    }
    return FALSE;
}

// Returns a list of entity types that have records enabled
function mukurtu_taxonomy_records_entity_list() {
    $entity_records = array();
    
    $entity_info = entity_get_info();

    // Currently only supporting scald_atom and node
    $supported_types = array('scald_atom', 'node');

    // Check each supported type for the 'field_mukurtu_terms' field
    foreach($supported_types as $type) {
        foreach($entity_info[$type]['bundles'] as $bundle => $bundle_info) {
            $instance = field_info_instance($type, 'field_mukurtu_terms', $bundle);
            if($instance) {
                $entity_records[$type][$bundle] = $bundle_info['label'];
            }
        }
    }

    return $entity_records;
}

function mukurtu_taxonomy_records_is_record($entity, $entity_type = 'node') {
    if(!isset($entity->type)) {
        return FALSE;
    }

    $supported_list = mukurtu_taxonomy_records_entity_list();
    if(isset($supported_list[$entity_type])) {
        foreach($supported_list[$entity_type] as $bundle => $bundle_label) {
            if($entity->type == $bundle) {                
                return TRUE;
            }                
        }
    }
    if(isset($entity->field_mukurtu_terms)) {
        //        return TRUE;
    }
    return FALSE;
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function mukurtu_taxonomy_records_contextual_links_view_alter(&$element, $items) {
    if(isset($element['#element']['#node']) && mukurtu_taxonomy_records_is_record($element['#element']['#node']) && $element['#element']['#view_mode'] == 'full') {
        $term = menu_get_object('taxonomy_term', 2);
        if($term) {
            if(node_access('update', $element['#element']['#node'])) {
                // Add detach button'
                $tid = $term->tid;
                $element['#links']['mukurtu-records'] = array(
                    'title' => t("Remove this record"),
                    'href' => url("/taxonomy/term/$tid/remove-record/" . $element['#element']['#node']->nid,
                                  array('absolute' => TRUE,'query' => drupal_get_destination()))
                );
            }
        }
    }
}