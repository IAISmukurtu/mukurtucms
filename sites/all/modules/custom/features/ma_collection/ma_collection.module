<?php
/**
 * @file
 * Code for the Collection feature.
 */

include_once('ma_collection.features.inc');

/**
 * Implements hook_user_logout().
 */
// Delete the cookie that holds the Collections browse mode setting
function ma_collection_user_logout ($account) {
  setcookie('collections_browse_mode', '', 1, '/');
}

/**
 * Implements template_preprocess_views_view.
 */
function ma_collection_preprocess_views_view(&$vars) {
  $view = &$vars['view'];

  // Add JS for browse mode switcher on Collections view
  if ($view->name == 'collections_grid_list') {
    drupal_add_library('system', 'jquery.cookie');
    drupal_add_js(drupal_get_path('module', 'ma_collection') . '/js/collection_browse_mode_switcher.js');
  }

}

function ma_collection_node_view($node, $view_mode) {

  // On full node view of node types that can be added to a Collection, load the "Add to Collection" ctools modal JS.
  if ($view_mode == 'full') {
    if (in_array($node->type, ma_collection_get_valid_node_types_for_collection())) {
      ma_collection_include_add_to_collection_modal_js();
    }
  }

  if ($node->type == 'collection') {

    if ($view_mode == 'search_result') {

      // In the Collections Grid/List view, if there is no image uploaded for a Collection node, use the first available image atom from the Digital Heritage items in that Collection. If none of the DH items have an image atom, use the thumbnail from the first available non-image atom from the DH items in that Collection. If that atom does not have an uploaded thumbnail, use the default thumbnail for that atom type.

      if (!count($node->field_collection_image)) {
        $collection_emw = entity_metadata_wrapper('node', $node);

        $replacement_image = "";
        foreach ($collection_emw->field_digital_heritage_items->value() as $dh_item) {
          $dh_item_emw = entity_metadata_wrapper('node', $dh_item);
          if(isset($dh_item_emw->field_media_asset)) {
            foreach ($dh_item_emw->field_media_asset->value() as $dh_item_media_index => $dh_item_media) {
              if ($dh_item_media->provider == 'scald_image') {
                $replacement_image = scald_render ($dh_item_emw->field_media_asset->get($dh_item_media_index)->value(), 'ma_scald_search_results');
                break 2;
              }
              elseif (!$replacement_image) {
                // Use the atom thumbnail if there is one
                if (count($dh_item_media->scald_thumbnail)) {
                  $replacement_image = theme_image_style (array (
                    'style_name' => 'medium',
                    'path' => $dh_item_media->scald_thumbnail[LANGUAGE_NONE][0]['uri'],
                  ));
                }
                // If no atom thumbnail, use our default thumbnails
                else {
                  $replacement_image = '<img src = "/' . drupal_get_path('module', 'ma_digitalheritage') . '/images/default_' . $dh_item_media->type . '_thumbnail.jpg">';
                }
              }
            }
          }
        }

        if (isset($replacement_image)) {
          // Rewrite the image field
          $node->content['field_collection_image'] = array(
            '#theme' => 'field',
            '#title' => 'Image',
            '#access' => true,
            '#formater' => 'ma_scald_search_results',
            '#view_mode' => 'search_result',
            '#label_display' => 'hidden',
            '#field_name' => 'field_collection_image',
            '#entity_type' => 'node',
            '#bundle' => 'collection',
            '#weight' => 0,
            '#items' => array(0 => 1), // this just needs at least one value in it
          );

          $node->content['field_collection_image'][0]['#markup'] = $replacement_image;
        }
      }

      // Tooltip and links on DH grid/list views
      if (isset($node->content['field_collection_image'])) {
        foreach ($node->content['field_collection_image'] as $atom_index => $atom) {
          if (!is_numeric($atom_index)) {
            continue;
          }

          // Using CSS for the tooltip (see comments in ma_digitalheritage_node_view for explanation)
          // Also add link here to parent node
          $new_markup = '<a class = "tooltips" href=" ' . url("node/" . $node->nid) . '">' . $atom['#markup'] . '</a>';

          $node->content['field_collection_image'][$atom_index]['#markup'] = $new_markup;

        }
      }

    }

  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_collection_form_views_exposed_form_alter(&$form, &$form_state) {

  // Add a button to reset search and filters
  // Search API provides a button on the view that will reset the search, but not the filters. Leaving that off and creating our own that will reset both.
  if (strpos($form['#id'], 'views-exposed-form-collections-grid-list-all') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = array('#markup' => l(t('Reset'),'collections', array('attributes' => array('class' => array ('btn', 'btn-primary', 'form-submit')), 'html' => TRUE)));
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function ma_collection_node_presave($node) {

  // Populate the Digital Heritage Count
  if ($node->type == 'collection') {
    $collection_presave_skip = variable_get('collection_presave_skip', array());
    if (array_key_exists($node->nid, $collection_presave_skip)) {
      unset ($collection_presave_skip[$node->nid]);
      variable_set('collection_presave_skip', $collection_presave_skip);
      return;
    }

    $collection_emw = entity_metadata_wrapper('node', $node);
    $new_count = $collection_emw->field_digital_heritage_items->count();
    $collection_presave_skip[$node->nid] = $node->nid;
    variable_set('collection_presave_skip', $collection_presave_skip);
    $collection_emw->field_digital_heritage_count->set ($new_count);
    $collection_emw->save();
  }

}

/**
 * Implements hook_node_insert().
 */
function ma_collection_node_insert($node) {
  if ($node->type == 'digital_heritage') {
    ma_collection_node_update($node);
  }
}

/**
 * Implements hook_field_attach_delete().
 */
// We need to use this hook instead of hook_node_delete because hook_node_delete runs too early
function ma_collection_field_attach_delete ($entity_type, $entity) {
  if (isset($entity->type) && $entity->type == 'digital_heritage') {
    ma_collection_node_update($entity, 1);
  }
}

/**
 * Implements hook_node_update().
 */
function ma_collection_node_update($node, $deleted = NULL) {

  // Update the Digital Heritage Count on Collection nodes when a DH node adds or removes a Collection reference, or a DH node with a Collection reference is deleted, or a DH node with a Collection reference is cloned
  if ($node->type == 'digital_heritage') {
    $wrapper_new = entity_metadata_wrapper('node', $node);
    $new_refs = ma_core_get_nids_from_array_of_nodes($wrapper_new->field_collection->value());
    $old_refs = array();
    if (!$deleted AND isset($node->original)) {
      $wrapper_old = entity_metadata_wrapper('node', $node->original);
      $old_refs = ma_core_get_nids_from_array_of_nodes($wrapper_old->field_collection->value());
    }
    if ($old_refs <> $new_refs) {
      $refs_added = array_diff ($new_refs, $old_refs);
      $refs_deleted = array_diff ($old_refs, $new_refs);
      $collections_to_recount = array_merge ($refs_added, $refs_deleted);
      foreach ($collections_to_recount as $collection) {
        if($collection == NULL) {
          continue;
        }
        $query = new EntityFieldQuery();
        $result = $query
          ->entityCondition('entity_type', 'node')
          ->entityCondition('bundle', 'digital_heritage')
          ->propertyCondition('status', NODE_PUBLISHED) // or else it will retrieve node references for deleted DH items
          ->fieldCondition('field_collection', 'target_id', $collection)
          ->execute();
        $new_count = count($result['node']);
        $collection_presave_skip = variable_get('collection_presave_skip', array());
        $collection_presave_skip[$collection] = $collection;
        variable_set('collection_presave_skip', $collection_presave_skip);
        $collection_emw = entity_metadata_wrapper('node', $collection);
        if($collection_emw) {
          $collection_emw->field_digital_heritage_count->set($new_count);
          $collection_emw->save();
        }
      }
    }
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * Collection node form alter.
 */
function ma_collection_form_collection_node_form_alter(&$form, $form_state) {
  $node = $form['#node'];

  // Collections Tree in the collection node form

  //  Top-level Collection field should generally be hidden, as we only want to set sub-collections in top-level collection, and restrict the other way around.
  $form['field_collections_parent_coll']['#access'] = FALSE;
  // If this is a sub-collection, then...
  if (isset($node->field_collections_parent_coll[LANGUAGE_NONE][0])) {
    // ...show the top-level collection field, but do not allow editing.
    $form['field_collections_parent_coll']['#access'] = TRUE;
    $form['field_collections_parent_coll']['#disabled'] = TRUE;
    // ...hide the sub-collections field.
    $form['field_collections_child_coll']['#access'] = FALSE;
  }

  // Creating a new Collection
  if (!isset($node->nid)) {

    // Prepopulate any "Add To Collection" nodes in the entity refs.
    $query = drupal_get_query_parameters();
    if (isset($query['add'])) {
      $add = explode('-', $query['add']);
      $entity_ref_field = array_search($add[0], ma_collection_get_valid_node_types_for_collection());
      if (isset($entity_ref_field) && is_numeric($add[1])) {
        $node_to_add = node_load($add[1]);
        $form[$entity_ref_field][LANGUAGE_NONE][0]['target_id']['#default_value'] = $node_to_add->title . ' (' . $node_to_add->nid . ')';
      }
    }

  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * When deleting a Collection, let the user know on the confirmation message that the DH items will remain.
 */
function ma_collection_form_node_delete_confirm_alter(&$form, $form_state) {
  $node = $form['#node'];
  if ($node->type == 'collection') {
    $form['description']['#markup'] = "<p>This action cannot be undone.</p>This will delete the Collection but not the Digital Heritage items within the Collection.</p>";
  }
}

// Rewrite the Collection node title in the Collection search view to show a count of DH items
function ma_collection_collections_title_with_count_and_tree_popup ($entity) {

  // Get the DH count
  $dh_count = 0;
  $coll_wrapper = entity_metadata_wrapper('node', $entity);
  $dhs = $coll_wrapper->field_digital_heritage_items->value();
  if (count($dhs)) {
    if (user_access('bypass content access control')) {
      $dh_count = count($dhs);
    }
    else {
      foreach ($dhs as $dh) {
        if (node_access('view', $dh)) {
          $dh_count++;
        }
      }
    }
  }

  $title = '<h2>' . $entity->title . ' (' . $dh_count . ')</h2>';
  $path = 'node/' . $entity->nid;

  // Get the collection tree.
  if ($tree = ma_collection_collections_tree($entity)) {
    module_load_include('inc', 'popup', 'includes/popup.api');
    $attributes = [
      'link' => $path,
      'origin' => 'top-right',
      'expand' => 'top-right',
      // 'activate' => 'click', 'close' => 1, // uncomment this to tweak CSS in the inspector
      'width' => '100%',
      'class' => 'collections-tree-popup',
    ];
    $output =  popup_element($title, $tree, $attributes);
  }
  // Standalone collections have no tree.
  else {
    $output = l($title, $path, ['html' => TRUE]);
  }
  return $output;
}


/**
 * Implements hook_menu().
 */
function ma_collection_menu() {
  $items = array();

  // "Add to Collection" ajax.
  $items['ma_collection/%ctools_js'] = array(
    'page callback' => 'ma_collection_add_to_collection_callback',
    'page arguments' => array(1, 2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Add "Add to Collection" node view nav tab.
  $items['node/%node/add_to_collection'] = array(
    'title' => 'Add to Collection',
    'access callback' => 'ma_collection_add_node_to_collection_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  return $items;
}

/**
 * Add to Collection ajax callback.
 */
function ma_collection_add_to_collection_callback($ajax, $nid_to_add) {
  if ($ajax) {
    ctools_include('ajax');
    ctools_include('modal');
    $form_state = array(
      'ajax' => TRUE,
      'nid_to_add' => $nid_to_add,
    );
    // Use ctools to generate ajax instructions for the browser to create
    // a form in a modal popup.
    $output = ctools_modal_form_wrapper('ma_collection_add_to_collection_form', $form_state);
    // If the form has been submitted, there may be additional instructions
    // such as dismissing the modal popup.
    if (!empty($form_state['ajax_commands'])) {
      $output = $form_state['ajax_commands'];
    }
    // Return the ajax instructions to the browser via ajax_render().
    print ajax_render($output);
    drupal_exit();
  }
  else {
    // We're assuming JS is enabled, so do nothing if not.
  }
}

/**
 * Rewrite the link path for the "Add to Collection" node view nav tab to the Ctools modal.
 *
 * The original path needs to be written as "node/{nid}/{path}" in order for the tab to show up in the node view.
 */
function ma_collection_url_outbound_alter(&$path, &$options, $original_path) {
  if (substr($path,-18) == '/add_to_collection') {
    $path_parts = explode('/', $path);
    if (is_numeric($path_parts[1])) {
      $path = 'ma_collection/nojs/' . $path_parts[1];
      $options['attributes'] = array('class' => 'ctools-use-modal ctools-modal-add-to-collection');
    }
  }
}

/**
 * Implements hook_contextual_links_view_alter().
 *
 * Add an "Add to Collection" contextual link to the search results nodes.
 */
function ma_collection_contextual_links_view_alter(&$element, $items) {

  if (!empty($element['#element']['#entity_type']) && !empty($element['#element']['#bundle']) && user_access('edit own collection content')) {
    if (in_array($element['#element']['#bundle'], ma_collection_get_valid_node_types_for_collection())) {
      $view_mode = isset($element['#element']['#view_mode']) ? $element['#element']['#view_mode'] : 'default';
      if ($view_mode == 'search_result') {

        // Conditions met. Add the link.
        ma_collection_include_add_to_collection_modal_js();
        $nid = $element['#element']['#node']->nid;
        $element['#links']['add_to_collection'] = array(
          'title' => t('Add to Collection'),
          'href' => 'ma_collection/nojs/' . $nid,
          'attributes' => array('class' => 'ctools-use-modal ctools-modal-add-to-collection'),
        );
      }
    }
  }
}

/**
 * "Add to Collection" form.
 */
function ma_collection_add_to_collection_form($form, $form_state) {

  $nid_to_add = $form_state['nid_to_add'];

  // First option is to create a new collection.
  $colls = [
    'create_new_collection' => 'Create a new Collection'
  ];

  // Build an array of collections.

  // First get collections that already have this node in it, so we can exclude them later.
  $colls_to_exclude = array();
  $valid_collection_types = ma_collection_get_valid_node_types_for_collection();
  foreach ($valid_collection_types as $entity_reference_field => $node_type) {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'collection')
      ->fieldCondition($entity_reference_field, 'target_id', $nid_to_add);
    $result = $query->execute();
    if (isset($result['node'])) {
      $colls_to_exclude = array_keys($result['node']);
    }
  }

  // Get the collections.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'collection')
    ->propertyCondition('status', NODE_PUBLISHED);
  $result = $query->execute();
  if (isset($result['node'])) {
    $coll_nids = array_keys($result['node']);
    foreach ($coll_nids as $coll_nid) {
      if (in_array($coll_nid, $colls_to_exclude)) {
        continue;
      }
      $coll_node = node_load($coll_nid);
      if (node_access('update', $coll_node)) { // exclude nodes user does not have permission to edit.
        $colls[$coll_nid] = $coll_node->title;
      }
    }

    // Build the form.

    $form['collection'] = [
      '#title' => t('Add Item to Collection'),
      '#type' => 'select',
      '#options' => $colls,
      '#chosen' => TRUE,
      // '#attributes' => array('onchange' => 'this.form.submit();'), // does not work in this context, so we need the submit button.
    ];
    $form['actions'] = [
      'submit' => [
        '#type' => 'submit',
        '#value' => t('Add'),
      ],
      'cancel' => [
        '#type' => 'submit',
        '#value' => t('Cancel'),
      ],
    ];
  }
  return $form;
}

/**
 * Add to Collection form submit handler.
 */
function ma_collection_add_to_collection_form_submit(&$form, &$form_state) {

  // Tell the browser to close the modal.
  $form_state['ajax_commands'][] = ctools_modal_command_dismiss();

  // Skip if user pressed Cancel.
  if ($form_state['values']['op'] == "Cancel") {
    return;
  }

  $coll_nid = $form_state['values']['collection'];
  if ($coll_nid) {

    $nid_to_add = $form_state['nid_to_add'];
    $node_to_add = node_load ($nid_to_add);

    if ($entity_ref_field = array_search($node_to_add->type, ma_collection_get_valid_node_types_for_collection())) {

      // Create a new Collection
      if ($coll_nid == 'create_new_collection') {
        ctools_include('ajax');
        ctools_add_js('ajax-responder');
        $query = [];
        $query['add'] = $node_to_add->type . '-' . $nid_to_add;
        $referer = parse_url($_SERVER['HTTP_REFERER']); // Using referring page because current path is ajax callback.
        if (isset($referer['path'])) {
          $query['destination'] = substr($referer['path'], 1);
        }
        $commands[] = ctools_ajax_command_redirect('node/add/collection', 0, ['query' => $query]);
        print ajax_render($commands);
        exit;
      }

      // Add to existing Collection
      $coll_node = node_load($coll_nid);
      if (node_access('update', $coll_node)) {

        // Add the item to the Collection node.
        $cw = entity_metadata_wrapper('node', $coll_node);
        $cw->{$entity_ref_field}[] = $nid_to_add;
        $cw->save(); // comment this line while debugging.

        // Display confirmation message.
        // EntityDrupalWrapper::save throws an exception if it fails, so if we get here, we know it worked.
        $output = '<p>' . node_type_get_name($node_to_add) . ' <i>' . $node_to_add->title . '</i> has been added to Collection <i>' . $coll_node->title . '</i>.</p>';
        $output .= '<div><button type="submit" class="btn btn-success ctools-close-modal">OK</button></div>';
        $ctools_output[] = ctools_modal_command_display('Success', $output);
        print ajax_render($ctools_output);
        exit;

      }
    }
  }
}

/**
 * Helper function to add the JS for an "Add To Collection" ctools modal.
 *
 * This uses AJAX and ctools to put a form into a modal.
 */
function ma_collection_include_add_to_collection_modal_js() {

  if (user_access('edit own collection content')) {
    ctools_include('modal'); // This is included statically by Ctools so no performance risk of multiple loading.
    drupal_add_js([
      'add-to-collection' => [
        'modalClass' => 'add-to-collection',
        'modalSize' => [
          'type' => 'fixed',
          'width' => 250,
          'height' => 250,
          'contentRight' => 0,
          'contentBottom' => 0,
        ],
      ],
    ], 'setting');
    ctools_modal_add_js(); // This is added statically by Ctools so no performance risk of multiple loading.
  }
}

/**
 * Access callback for the "Add to Collection" node view tab.
 */
function ma_collection_add_node_to_collection_access($node) {
  if (user_access('edit own collection content')) {
    if (in_array($node->type, ma_collection_get_valid_node_types_for_collection())) {
      return TRUE;
    }
  }
}

/**
 * Helper function to return types of content that can be added to a collection, and the collection entity reference field for that type.
 *
 * Currently just DH, but more will be added here later.
 */
function ma_collection_get_valid_node_types_for_collection() {
  return [
    'field_digital_heritage_items' => 'digital_heritage',
  ];
}

/**
 * Implements hook_views_pre_view().
 */
function ma_collection_views_pre_view(&$view, &$display_id, &$args) {

  // When editing a collection, allow the current collection as the parent collection on the subcollections filters.
  // Using an argument in a view filter, we would normally use a contextual filter, but we need to put this in a filter
  // group to also allow collections with no parents, thus we need to use a regular filter, so we sub the argument here.
  if ($view->name == 'child_collections_entity_reference') {
    $filters = $view->display_handler->get_option('filters');
    if (is_numeric(arg(1))) {
      $filters['field_collections_parent_coll_target_id']['value']['value']=arg(1);
      $view->display_handler->override_option('filters', $filters);
    }
  }
}

/**
 * Render a collection tree, and the current node's place within that tree.
 */
function ma_collection_collections_tree($current, $popup = 0) {

  if (isset($current->field_collections_child_coll[LANGUAGE_NONE])) {
    $parent = $current;
  }
  elseif (isset($current->field_collections_parent_coll[LANGUAGE_NONE])) {
    $parent = node_load($current->field_collections_parent_coll[LANGUAGE_NONE][0]['target_id']);
  }

  if (isset($parent)) {
    $children = $parent->field_collections_child_coll[LANGUAGE_NONE];

    foreach ($children as $child_i => &$child) {
      $child['id'] = $child_i + 1;
      $child['parent_delta'] + 1;
      $child_node = node_load($child['target_id']);
      if ($current->nid == $child_node->nid) {
        $child['data'] = '<span class="current";>' . $current->title . '</span>';
      }
      else {
        $child['data'] = l($child_node->title, 'node/' . $child_node->nid);
      }
    }
    // Buid a recursive array out of the flat array.
    $children_tree = buildTree($children);

    // Put the parent at the top, with the children below.
    if ($current->nid == $parent->nid) {
      $parent_data = '<span class="current";>' . $parent->title . '</span>';
    }
    else {
      $parent_data = l($parent->title, 'node/' . $parent->nid);
    }
    $items = [[
      'data' =>  $parent_data,
      'children' => $children_tree,
      'class' => ['parent']
    ]];

    // theme_item_list correctly nests recursive arrays.
    // The CSS to make the nested list look like a tree is based on http://odyniec.net/articles/turning-lists-into-trees/
    $output = theme('item_list', array('items' => $items, 'attributes' => array('class' => array('collections-tree'))));
    return $output;

  }
}

// Recursive helper function to build a recursive array out of an flat array with parent refs.
// From https://stackoverflow.com/a/8587437/5128322.
function buildTree(array $elements, $parentId = 0) {
  $branch = array();
  foreach ($elements as $element) {
    if ($element['parent_delta'] == $parentId) {
      $children = buildTree($elements, $element['id']);
      if ($children) {
        $element['children'] = $children;
      }
      $branch[] = $element;
    }
  }
  return $branch;
}
