<?php
/**
 * @file
 * Code for the Mukurtu Digital Heritage Admin Notifications feature.
 */

include_once 'ma_dhan.features.inc';


//
//
///**
// * Implements hook_node_delete().
// */
//function ma_dhan_node_delete($node) {
//
//  // TODO change this
//
//  // If a child node is deleted, also delete its Following node.
//  if (in_array($node->type, ma_culturalprotocol_collab_child_node_types())) {
//    if ($following_nid = ma_dhan_get_following_nid($node->nid)) { // This condition should always be met.
//      node_delete($following_nid);
//    }
//  }
//}

/**
 * Implements hook_node_insert().
 */
function ma_dhan_node_insert($node) {

  ////
  // Create a DHAN when a DH node is created.
  ////

  if ($node->type == 'digital_heritage') {

    // Create and save the DHAN node.
    $values = array(
      'type' => 'dhan',
      'uid' => 1,
      'status' => 1,
    );
    $dhan_node = entity_create('node', $values);
    $dhan_node_w = entity_metadata_wrapper('node', $dhan_node);
    $dhan_node_w->title->set($node->title . ' (DHAN)');
    $dhan_node_w = ma_dhan_set_dhan_node_lists_on_following_node_wrapper($node, $dhan_node_w);
    $dhan_node_w->field_following_content->set($node->nid);
    $dhan_node_w->save();

    // Attach the dhan_node email field collection to the dhan_node node.
    ma_dhan_set_dhan_node_email_fc($dhan_node_w, $node, 'created');

    // Update field_all_users_notified
    $dhan_node_w = entity_metadata_wrapper('node',  $dhan_node_w->getIdentifier()); // reload the dhan_node wrapper, since it may have been updated in ma_dhan_field_collection_item_insert (as fired from ma_dhan_set_dhan_node_email_fc)
    ma_dhan_update_field_all_users_notified($dhan_node_w);

  }

}

///**
// * Implements hook_node_update().
// */
//function ma_dhan_node_update($node) {
//
//  ////
//  // Create a Following Notification when a child page is updated.
//  ////
//
//  if (in_array($node->type, ma_culturalprotocol_collab_child_node_types())) {
//    $entity_new = $cw = entity_metadata_wrapper('node', $node);
//    $entity_old = entity_metadata_wrapper('node', $node->original);
//
//    // When updating a child page, only create a following email FC instance if certain fields are changed.
//    // If only a Following field is changed, instead update the Following node instead.
//    // This diff'ing code is somewhat modified from https://drupal.stackexchange.com/a/175186/83739.
//    // Also using helper functions added to ma_core.
//    // $properties_within_fields_to_ignore does what it says, wherein those properties can be nested anywhere within the field that is being compared.
//    $ignore_fields = [
//      'field_pre_actions',
//      'path',
//      'redirect',
//      'og_group_ref',
//      'field_community_ref',
//      'field_item_privacy_setting',
//    ];
//    $properties_within_fields_to_ignore = [
//      'safe_value',
//      'safe_summary',
//      'all_day',
//      'show_repeat_settings',
//      'show_todate',
//      'offset',
//      'offset2',
//    ];
//    $ignore_fields = array_merge ($ignore_fields, ma_dhan_get_all_child_ref_fields());
//    $following_fields = [
//      'field_following_protocols',
//      'field_dhan_notified_users',
//      'field_un_following_users',
//      'field_custom_notification_freq',
//    ];
//
//    $following_diff_list =  array();
//    $data = array_merge(['title' => ['label' => 'Title']], field_info_instances('node' ,$entity_new->getBundle()));
//    $fields_list = array_keys($data);
//    $diff_list =  array();
//    foreach ($fields_list as $key => $field_name ) {
//      // Ignore if field name belong to ignore list
//      if(in_array($field_name, $ignore_fields )) {
//        continue;
//      }
//      $old_value = $entity_old->{$field_name}->raw();
//      $new_value = $entity_new->{$field_name}->raw();
//      // If both are empty - ignore
//      if(empty($old_value) && empty($new_value)) {
//        continue;
//      }
//      // If one of the value is not empty compared to the other
//      if( (empty($old_value) && !empty($new_value) ) || (empty($new_value) && !empty($old_value))){
//        // You can use field_get_items() to get the changed value.
//        if (in_array($field_name, $following_fields)) {
//          $following_diff_list[$field_name] = $data[$field_name]['label'];
//        }
//        else {
//          $diff_list[$field_name] = $data[$field_name]['label'];
//        }
//        continue;
//      }
//      if(!is_array($new_value) && $new_value != $old_value) {
//        if (in_array($field_name, $following_fields)) {
//          $following_diff_list[$field_name] = $data[$field_name]['label'];
//        }
//        else {
//          $diff_list[$field_name] = $data[$field_name]['label'];
//        }
//        continue;
//      }
//      if(is_array($new_value) && is_array($old_value)) {
//        foreach ($properties_within_fields_to_ignore as $property_to_ignore) {
//          recursive_unset($new_value, $property_to_ignore);
//          recursive_unset($old_value, $property_to_ignore);
//        }
//        $diff1 = array_diff_assoc_recursive($new_value, $old_value);
//        $diff2 = array_diff_assoc_recursive($old_value, $new_value);
//        if($diff1 or $diff2) {
//          if (in_array($field_name, $following_fields)) {
//            $following_diff_list[$field_name] = $data[$field_name]['label'];
//          }
//          else {
//            $diff_list[$field_name] = $data[$field_name]['label'];
//          }
//        }
//      }
//    }
//
//    $following_nid = ma_dhan_get_following_nid($node->nid);
//    if (!$following_nid) { // this should never happen but log an error in case it does.
//      watchdog('ma_dhan', 'There is no Following node for node %nid', array('%nid' => $node->nid), WATCHDOG_ERROR);
//      return;
//    }
//    $notification_w = entity_metadata_wrapper('node', $following_nid);
//
//    // First update the Following node, if there are changes to the following fields.
//    if (count($following_diff_list)) {
//      $notification_w = ma_dhan_set_dhan_node_lists_on_following_node_wrapper($node, $notification_w);
//      $notification_w->save();
//    }
//
//    // Then, if there are changes to the other fields, first unset the users_notified on the Following node, then add a new Following email FC.
//    if (count($diff_list)) {
//      $notification_w->field_users_notified->set([]);
//      $notification_w->save();
//      ma_dhan_set_notification_email_fc($notification_w, $node, 'updated');
//    }
//
//    // Update field_all_users_notified
//    if (count($following_diff_list) OR count ($diff_list)) {
//      $notification_w = entity_metadata_wrapper('node', $following_nid); // reload the notification wrapper, since it may have been updated in ma_dhan_field_collection_item_insert (as fired from ma_dhan_set_notification_email_fc)
//      ma_dhan_update_field_all_users_notified($notification_w);
//    }
//
//  }
//}

// Update field_all_users_notified
function ma_dhan_update_field_all_users_notified($dhan_node_w) {
  $all_users_to_notify = $dhan_node_w->field_notify_all->raw();
  $already_notified = $dhan_node_w->field_users_notified->raw();
  $all_users_notified = 1;
  if (count(array_diff($all_users_to_notify, $already_notified))) {
    $all_users_notified = 0;
  }
  if ($all_users_notified <>  $dhan_node_w->field_all_users_notified->value()) {
    $dhan_node_w->field_all_users_notified->set($all_users_notified);
    $dhan_node_w->save();
  }
}




// Set the notification lists on a DHAN node wrapper (to be saved by calling function).
function ma_dhan_set_dhan_node_lists_on_following_node_wrapper($dh_node, $dhan_node_w) {

  $dh_w = entity_metadata_wrapper('node', $dh_node);



  // Build the list of parent comms and cps.
  $comms_cps = [];
  foreach ($dh_node->field_community_ref[LANGUAGE_NONE] as $comm) {
    $comms_cps[] = $comm['nid'];
  }
  foreach ($dh_node->og_group_ref[LANGUAGE_NONE] as $cp) {
    $comms_cps[] = $cp['target_id'];
  }

  // Build the notify list.
  $notify_list = [];
  foreach ($comms_cps as $comm_cp_nid) {
    $comm_cp_node = node_load($comm_cp_nid);
    if (isset($comm_cp_node->field_dhan_notified_users[LANGUAGE_NONE])) {
      $notify_list = array_merge($notify_list, array_column($comm_cp_node->field_dhan_notified_users[LANGUAGE_NONE], 'target_id'));
    }
  }
  // Remove duplicates
  $notify_list = array_unique($notify_list);

  // Build notify_frequency lists.
  $notify_frequency = [
    'right away' => [],
    'daily digest' => [],
    'weekly digest' => [],
  ];
  foreach ($notify_list as $notify_uuid) {
    $account = user_load($notify_uuid);
    $user_frequency = isset($account->field_dhan_frequency[LANGUAGE_NONE][0]['value']) ? $account->field_notifications_freq_def[LANGUAGE_NONE][0]['value'] : 'right away';
    $notify_frequency[$user_frequency][] = $notify_uuid;
  }

  // Set the fields on the notification wrapper, and return the wrapper to be saved in calling function.
  $dhan_node_w->field_notify_immediately->set($notify_frequency['right away']);
  $dhan_node_w->field_notify_day->set($notify_frequency['daily digest']);
  $dhan_node_w->field_notify_week->set($notify_frequency['weekly digest']);
  $dhan_node_w->field_notify_all->set(array_merge($notify_frequency['right away'], $notify_frequency['daily digest'], $notify_frequency['weekly digest']));

  return $dhan_node_w;
}


// Attach the dhan email field collection to a given dhan node.
function ma_dhan_set_dhan_node_email_fc($notification_w, $dh_node, $op, $comment = NULL) {
  $fc_email = entity_create('field_collection_item', array('field_name' => 'field_notification_email'));
  $fc_email->setHostEntity('node', node_load($notification_w->getIdentifier()));
  $fce_w = entity_metadata_wrapper('field_collection_item', $fc_email);

  // Set the time
  $fce_w->field_notification_date_gene->set(time());

  // Set the subject
  $fce_w->field_notification_subject->set('"' . $dh_node->title . '" has been ' . $op . '.');

  // Set the body
  switch ($op) {
    case 'updated':
      global $user;
      $author_id = $user->uid;
      $dh_path = $dh_node->path["alias"];
    case 'created':
      $author_id = $dh_node->uid;
      $dh_path =  pathauto_create_alias('node', 'return', '/node/' . $dh_node->nid, ['node' => $dh_node], $dh_node->type);
      break;
  }
  $body = 'The Digital Heritage item "' . $dh_node->title . '", was ' . $op . ' by ' . $dh_node->name . ' on ' . date('l, F j', $dh_node->timestamp) . ' at ' . date('g:ia', $dh_node->timestamp) . '.';
  $body .= '\n\nYou are being notified of this because you have chosen to receive notifications for either a Community or a Protocol that this item is in.';
  $body .= '\n\nView the Digital Heritage item: ' . $GLOBALS["base_url"] . '/' . $dh_path;
  $fce_w->field_notification_body->set($body);

  // Set the notification "author".
  $fce_w->field_notification_author->set($author_id);

  // Save the field collection.
  $fce_w->save();
}

//
///**
// * Implements hook_field_collection_item_insert()
// *
// * After creating a new Following notification email FC, send out notifications for the "immediately" users and update the Following notification users notified field.
// */
//function ma_dhan_field_collection_item_insert($fc_item){
//  if ($fc_item->field_name == 'field_notification_email') {
//    $notification_w = entity_metadata_wrapper('node', $fc_item->hostEntity());
//    $notify_users = array_diff($notification_w->field_notify_immediately->raw(), $notification_w->field_users_notified->raw());
//
//    // Send notifications.
//    $notification_author = $fc_item->field_notification_author[LANGUAGE_NONE][0]['target_id'];;
//    if (count($notify_users)) {
//      foreach ($notify_users as $uid) {
//        // Do not notify users of their *own* node creations / node edits / or comments.
//        if ($uid == $notification_author) {
//          $successful_sends[] = $uid;
//          continue;
//        }
//        $params = [
//          'subject' => $fc_item->field_notification_subject[LANGUAGE_NONE][0]['value'],
//          'body' => $fc_item->field_notification_body[LANGUAGE_NONE][0]['value'] .  "\n\nManage your notifications: " . $GLOBALS['base_url'] . "/user/" . $uid . "/following",
//
//        ];
//        if (isset($fc_item->field_notification_comment[LANGUAGE_NONE][0]['target_id'])) {
//          $params['comment_id'] = $fc_item->field_notification_comment[LANGUAGE_NONE][0]['target_id'];
//          $params['uid'] = $uid;
//        }
//        $user = user_load($uid);
//        $result = drupal_mail('ma_dhan', 'collab_notification', $user->mail, language_default(), $params);
//        if ($result['result']) { // This doesn't guarantee much but it's better than nothing.
//          $successful_sends[] = $uid;
//        }
//      }
//
//      // Update the notified users field.
//      if (count($successful_sends)) {
//        $notification_w->field_users_notified->set($successful_sends); // This saves automatically, because the FC already exists. Saving the wrapper separately creates a duplicate error.
//      }
//
//    }
//  }
//}
//
///**
// * Implements hook_mail().
// */
//function ma_dhan_mail($key, &$message, $params) {
//
//  if ($key == 'collab_notification') {
//
//    // For comments on immediate-send notications
//    if (isset($message['params']['comment_id'])) {
//      $comment = comment_load($message['params']['comment_id']);
//
//      // Embed the comment in the email body. This requires rebuilding the email body from its
//      // standard format (that of how non-comment notifications, and comment notifications in digests appear).
//      $body_prefix = variable_get('mailcomment_reply_text');
//      $split_body = preg_split("/.\n\nView the comment: /", $params['body']);
//      $comment_body = '| ' . drupal_html_to_text(wordwrap($comment->subject, 75, "\n| ", true)); // limit each line to 77 chars, including a "| " at the start of each line to denote quoted text.
//      $body_suffix = 'You may reply directly to this comment via email, or go to the comment at: ';
//      $params['body'] = $body_prefix . "\n\n" . $split_body[0] . ":\n\n" . $comment_body . "\n" . $body_suffix . $split_body[1];
//      //      $messageid_params['uid'] = $params['uid'];
//      //      $message['body'][0] .= 'View original post: ' . url('mailcomment/redirect/' . mailcomment_build_messageid($messageid_params), ['absolute' => TRUE]);
//
//      // Add ability to reply to the comment via email, using an auth code in the Message-ID header.
//      // This is taken from mailcomment_message_notify_mail_alter().
//      $messageid_params = [];
//      $messageid_params['uid'] = $comment->uid;
//      $messageid_params['cid'] = $comment->cid;
//      $messageid_params['nid'] = $comment->nid;
//      $messageid_params['time'] = $comment->created;
//      $reply = variable_get('mailcomment_mailbox', variable_get('site_mail', ''));
//      $message['headers']['Reply-To'] = $reply;
//      $message['headers']['Message-ID'] = mailcomment_build_messageid($messageid_params);
//      $ancestor_msg_id = mailcomment_mail_comment_ancestor_message_id($messageid_params['nid'], $messageid_params['cid']);
//      if (isset($ancestor_msg_id)) { // TODO: test if this is necessary
//        $message['headers']['In-Reply-To'] = $ancestor_msg_id;
//      }
//
//    };
//
//    // All notifications (not just comments) need the body and subject set here.
//    $message['subject'] = $params['subject'];
//    $message['body'][] = $params['body'];
//
//  }
//}
//
///**
// *  Implements hook_form_alter().
// */
//function ma_dhan_form_alter(&$form, &$form_state, $form_id) {
//
//  // On Collab child pages
//  $node_type = str_replace('_node_form', '', $form_id, $count);
//  if ($count && in_array($node_type, ma_culturalprotocol_collab_child_node_types())) {
//
//
//    // Unfollowing Users should be viewable to anyone that can edit this node, but not editable. Only the users themselves should be able to do that through the Unfollow button.
//    $form['field_un_following_users']['#disabled'] = TRUE;
//
//    // Restrict the Protocols the user can set to those they are a Steward of (or it is already set on the node).
//    $existing_protocols = $form['field_following_protocols'][LANGUAGE_NONE]['#default_value']; // Existing protocols need to be added separately for cases where the editing user is not a protocol steward of a referenced protocol. It still needs to be an option if it was already set on the node.
//    $existing_protocols_with_titles = []; //
//    foreach ($existing_protocols as $existing_protocol) {
//      $existing_protocol_node = node_load ($existing_protocol);
//      $existing_protocols_with_titles[$existing_protocol] = $existing_protocol_node->title;
//    }
//    $valid_protocols_with_titles = ma_cultural_protocol_get_cps_user_is_steward();
//    $referenceable_cps = $existing_protocols_with_titles + $valid_protocols_with_titles;
//    //    dpm ($existing_protocols_with_titles, 'existing');
//    //    dpm ($valid_protocols_with_titles, 'valid');
//    //    dpm ($referenceable_cps, 'referenceable');
//    $form['field_following_protocols'][LANGUAGE_NONE]['#options'] = $referenceable_cps;
//
//  }
//}
//
//
/**
 * Custom notification field.
 */
function ma_dhan_notification_field($entity) {

  $user_roles = og_get_user_roles('node', $entity->nid);
  if (in_array('protocol steward', $user_roles) OR in_array('community manager', $user_roles)) { // The Notify / Do not notify button should only show up is user is a CM or PS of the node.

    global $user;
    $user = user_load($user->uid); // Must reload user object to get the hidden field_notifications_freq_def field.

    $notified = ma_dhan_is_notified($entity, $user->uid);

    // Create output.
    if ($notified) {
      $output = 'You are receiving notifications {schedule}.';
      $output .= '<br />' . l('Stop receiving notifications.', 'node/' . $entity->nid . '/no-dhan');
    }
    else {
      $output = 'You are not receiving notifications.';
      $output .= '<br />' . l('Receive notifications.', 'node/' . $entity->nid . '/dhan');
    }

    //  if ($notified) {
    //    // Popup text node notification frequency form.
    //    $def_freq = isset($user->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $user->field_notifications_freq_def[LANGUAGE_NONE][0]['value'] : 'right away';
    //    $node_freq = ma_dhan_get_user_node_notification_frequency($entity, $user);
    //    $form = drupal_get_form('ma_dhan_notification_frequency_node_' . $entity->nid, $entity->nid, $def_freq, $node_freq);
    //    $popup_text .= drupal_render($form);
    //  }
    //
    //  // Add link to Following view.
    //  $popup_text .= '<span class="link-to-following-view">' . l('See all content you are following.', '/user/' . $user->uid . '/following') . '</span>';
    //
    //  // Generate the popup
    //  require_once drupal_get_path('module', 'popup') . '/includes/popup.api.inc';
    //  $popup_attributes = array (
    //    'style' => 'White',
    //    'origin' => 'top-left',
    //    'expand' => 'top-left',
    //    'width' => '400',
    //    'class' => 'follow-unfollow-popup',
    //    // 'activate' => 'click', 'close' => 1, // uncomment this to tweak CSS in the inspector
    //  );
    //  $output .= popup_element('Details.', $popup_text, $popup_attributes);

    return $output;

  }

}


///**
// * Helper function for Following view to show the default notification frequency form in the header.
// */
//function ma_dhan_show_default_notification_frequency_form($view) {
//  global $user;
//  if ($view->args[0] == $user->uid) {
//    $form = drupal_get_form('ma_dhan_notification_frequency_default');
//    return drupal_render($form);
//  }
//}
//
///**
// * Helper function for Following view to show Unfollow button.
// */
//function ma_dhan_show_unfollow_button_in_view($view, $data) {
//  global $user;
//  if ($view->args[0] == $user->uid) {
//    return l('<button class="btn btn-default">UnFollow</button>', 'node/' . $data->nid . '/unfollow', [
//      'html' => TRUE,
//      'query' => drupal_get_destination()
//    ]);
//  }
//}
//
//
///**
// * Helper function for Following view to show the per-node notification frequency form.
// */
//function ma_dhan_generate_notication_frequency_form($view, $data) {
//  global $user;
//  if ($view->args[0] == $user->uid) {
//    $viewed_user = user_load($view->args[0]);
//    $entity = node_load($data->nid);
//    $def_freq = isset($viewed_user->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $viewed_user->field_notifications_freq_def[LANGUAGE_NONE][0]['value'] : 'right away';
//    $node_freq = ma_dhan_get_user_node_notification_frequency($entity, $viewed_user);
//    $form = drupal_get_form('ma_dhan_notification_frequency_node_' . $entity->nid, $entity->nid, $def_freq, $node_freq);
//    return drupal_render($form);
//  }
//}
//
///**
// * Helper function for the Following view Parent field.
// */
//function ma_dhan_show_parent($nid) {
//  $child = node_load($nid);
//  $child_page_w = entity_metadata_wrapper('node', $child);
//  $parent =  ($child_page_w->{ma_dhan_get_child_ref_field_to_parent($child->type)}->value());
//  print l($parent->title, $parent->nid);
//}
//
//


/**
 * Returns if a given user is set to be notified on a given Protocol / Community.
 */
function ma_dhan_is_notified($entity, $uid) {
  if (isset($entity->field_dhan_notified_users[LANGUAGE_NONE])) {
    foreach ($entity->field_dhan_notified_users[LANGUAGE_NONE] AS $notified_user) {
      if ($uid == $notified_user['target_id']) {
        return TRUE;
      }
    }
  }
}

/**
 * Implementation of hook_menu().
 */
function ma_dhan_menu() {

  $items['node/%node/dhan'] = array(
    'page callback' => 'ma_dhan_notify_process',
    'page arguments' => array(1, 'dhan'),
    'access callback' => TRUE,
  );

  $items['node/%node/no-dhan'] = array(
    'page callback' => 'ma_dhan_notify_process',
    'page arguments' => array(1, 'no_dhan'),
    'access callback' => TRUE,
  );

//  $items['user/%user/following'] = array(
//    'title' => 'Following',
//    'page callback' => 'ma_dhan_following_view',
//    'page arguments' => array(1),
//    'access callback' => 'ma_dhan_following_view_access',
//    'access arguments' => array(1),
//    'type' => MENU_LOCAL_TASK,
//  );

  return $items;
}

/**
 * Callback to process the user clicking the notify / do not notify button.
 */
function ma_dhan_notify_process($node, $op) {
  global $user;
  $nw = entity_metadata_wrapper ('node', $node);
  if ($op=='dhan') {
    $nw->field_dhan_notified_users[] = $user->uid;
  }
  else {
    $new_notified_users = [];
    $notified_users = $nw->field_dhan_notified_users->value();
    foreach ($notified_users as $notified_user) {
      if ($notified_user->uid <> $user->uid) {
        $new_notified_users[] = $notified_user->uid;
      }
    }
    $nw->field_dhan_notified_users->set($new_notified_users);
  }
  $nw->save();
  drupal_goto('node/' . $node->nid);
}

//
///**
// * Access callback; Determine if user can view the Following tab on a given profile page.
// */
//function ma_dhan_following_view_access($account) {
//  global $user;
//  // Can view if own profile page
//  if ($user->uid == $account->uid) {
//    return TRUE;
//  }
//  // Can view if admin or Mukurtu admin
//  $admin = user_role_load_by_name('administrator');
//  $mukurtuadmin = user_role_load_by_name('Mukurtu Administrator');
//  if (user_has_role($admin->rid) || user_has_role($mukurtuadmin->rid)) {
//    return TRUE;
//  }
//}
//
///**
// * Page callback; Call a view to show what the the user's Followings.
// */
//function ma_dhan_following_view($account) {
//  $view = views_get_view('mukurtu_collab_subscriptions');
//  $view->set_arguments(array($account->uid));
//  return $view->preview();
//}
//
///**
// * Implements hook_views_post_execute.
// */
//function ma_dhan_views_post_execute(&$view) {
//
//  // Filter down the Following view. Views UI could not handle this, so we are doing it here.
//  // It would be better to do this in a views query alter so that pagers could work (as now there is no paging),
//  // plus more efficient, but I do not think it is possible. If this becomes slow then will need to set a hidden field
//  // on the child collab nodes which contains following lists of users which can be queried.
//  if ($view->name == "mukurtu_collab_subscriptions") {
//    $uid = $view->args[0];
//    foreach ($view->result as $i => $row) {
//      list ($following, $reasons) = ma_dhan_get_following_status_and_reasons(node_load ($row->nid), $uid);
//      if (!$following) {
//        unset ($view->result[$i]);
//      }
//    }
//  }
//}
//
///**
// * Notification default frequency form (header of the Following view).
// */
//function ma_dhan_notification_frequency_default($form, &$form_state) {
//  $account = user_load(arg(1));
//  $def_val = isset($account->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $account->field_notifications_freq_def['und'][0]['value'] : 'right away';
//  global $user;
//  $form = [
//    'notification_frequency_default' => [
//      '#type' => 'select',
//      '#title' => t('Notification Frequency Default: '),
//      '#options' => field_info_field('field_notifications_freq_def')['settings']['allowed_values'],
//      '#default_value' => $def_val,
//      '#disabled' => $user->uid <> $account->uid ? TRUE : FALSE,
//      '#attributes' => [
//        'onChange' => 'this.form.submit();',
//      ],
//    ],
//    'submit' => [
//      '#type' => 'submit',
//    ],
//  ];
//  return $form;
//}
//
///**
// * Submit handler for the notification default frequency form.
// */
//function ma_dhan_notification_frequency_default_submit ($form, &$form_state) {
//
//  $account = user_load(arg(1));
//  $existing_freq = $account->field_notifications_freq_def[LANGUAGE_NONE][0]['value'];
//  $new_freq = $form_state['values']['notification_frequency_default'];
//  if ($existing_freq <> $new_freq) {
//
//    // Update the notification default frequency on the user object.
//    $account->field_notifications_freq_def[LANGUAGE_NONE][0]['value'] = $new_freq;
//    user_save($account);
//
//    // Update the Following nodes for all child pages the user is following that are set to default frequency.
//    $frequency_field_map = [
//      'right away' => 'field_notify_immediately',
//      'daily digest' => 'field_notify_day',
//      'weekly digest' => 'field_notify_week',
//    ];
//    // Get all Following nodes the user is marked as a follower of.
//    $query = new EntityFieldQuery();
//    $result = $query
//      ->addMetaData('account', user_load(1))
//      ->entityCondition('entity_type', 'node')
//      ->entityCondition('bundle', 'following_notification')
//      ->propertyCondition('status', NODE_PUBLISHED)
//      ->fieldCondition('field_notify_all', 'target_id', $account->uid)
//      ->execute();
//    if (isset($result['node']) && count($result['node'])) {
//      // Loop through these, and check the child page if this user is using their default notification frequency for that node, and if so, update the Following node.
//      foreach (array_keys($result['node']) as $nid) {
//        $notification_w = entity_metadata_wrapper('node', $nid);
//        $custom_notification_freqs = $notification_w->field_following_content->field_custom_notification_freq->value();
//        if (count($custom_notification_freqs)) {
//          foreach ($custom_notification_freqs as $custom_notification_freq) {
//            if ($custom_notification_freq['first'] = $account->uid) {
//              $user_custom_freq_for_this_node = 1;
//              break;
//            }
//          }
//        }
//        if (!$user_custom_freq_for_this_node) {
//          $notification_w->{$frequency_field_map[$existing_freq]}->set(array_diff($notification_w->{$frequency_field_map[$existing_freq]}->raw(), [$account->uid])); // Remove the user from the old frequency
//          $notification_w->{$frequency_field_map[$new_freq]}[] = $account->uid; // Add the user to the new frequency
//          $notification_w->save();
//        }
//      }
//    }
//
//  }
//
//}
//
///**
// * Get the notification frequency for a given node and user.
// */
//function ma_dhan_get_user_node_notification_frequency($node, $user) {
//  if (isset($node->field_custom_notification_freq[LANGUAGE_NONE])) {
//    foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $custom_frequency) {
//      if ($custom_frequency['first'] == $user->uid) {
//        return $custom_frequency['second'];
//      }
//    }
//  }
//}
//
///**
// * Notification node frequency form (in the node frequency popup as well as a column in the Following view).
// */
//function ma_dhan_notification_frequency_node($form, &$form_state, $nid, $def_freq, $node_freq) {
//
//  $options = ['use default' => 'Use Default (' . ucwords($def_freq) . ')'] + field_info_field('field_notifications_freq_def')['settings']['allowed_values'];
//  $form = [
//    'notification_frequency_node' => [
//      '#type' => 'select',
//      '#title' => t('Notification frequency: '),
//      '#options' => $options,
//      '#default_value' => isset($node_freq) ? $node_freq : 'use default',
//      '#attributes' => [
//        'onChange' => 'this.form.submit();',
//      ],
//    ],
//    'nid' => [
//      '#type' => 'value',
//      '#value' => $nid,
//    ],
//    'submit' => [
//      '#type' => 'submit',
//    ],
//  ];
//  return $form;
//}
//
///**
// * Submit handler for the notification frequency sets the value on the node for the user, or unsets it if using default.
// */
//function ma_dhan_notification_frequency_node_submit ($form, &$form_state) {
//  global $user;
//  $val = $form_state['values']['notification_frequency_node'];
//  $node = node_load ($form_state['values']['nid']);
//  if ($val == 'use default') {
//    foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $i => $custom_frequency) {
//      if ($custom_frequency['first'] == $user->uid) {
//        unset ($node->field_custom_notification_freq[LANGUAGE_NONE][$i]);
//        node_save($node);
//        return;
//      }
//    }
//  }
//  else {
//    if (isset($node->field_custom_notification_freq[LANGUAGE_NONE])) {
//      foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $i => $custom_frequency) {
//        if ($custom_frequency['first'] == $user->uid) {
//          unset ($node->field_custom_notification_freq[LANGUAGE_NONE][$i]);
//        }
//      }
//    }
//    $node->field_custom_notification_freq[LANGUAGE_NONE][] = [
//      'first' => $user->uid,
//      'second' => $val,
//    ];
//    node_save($node);
//  }
//}
//
///**
// * Implementation of hook_forms()
// *
// * This is required because we are using the same form multiple times on the (Following) page. This allows for multiple form IDs calling the same form definition.
// */
//function ma_dhan_forms($form_id, $args) {
//  $forms = [];
//  if (strpos($form_id, 'ma_dhan_notification_frequency_node_') === 0) {
//    $forms[$form_id] = array(
//      'callback' => 'ma_dhan_notification_frequency_node',
//    );
//  }
//  return $forms;
//}
//
//
///**
// * Implementation of hook_cronapi.
// *
// * This hook is provided by Elysia Cron, which allows for scheduled cron jobs.
// */
//function ma_dhan_cronapi($op, $job = NULL) {
//  $items['ma_dhan_daily_notifications'] = array(
//    'description' => 'Send daily collaboration page notifications.',
//    'rule' => '0 8 * * *', // every day at 2am
//  );
//  $items['ma_dhan_weekly_notifications'] = array(
//    'description' => 'Send weekly collaboration page notifications.',
//    'rule' => '0 8 * * 1', // every Monday at 8am
//  );
//  return $items;
//}
//
//// Elysia cron notification callacks.
//function ma_dhan_daily_notifications() {
//  ma_dhan_send_scheduled_notifications('daily');
//}
//function ma_dhan_weekly_notifications() {
//  ma_dhan_send_scheduled_notifications('weekly');
//}
//
//// Send scheduled notifications, as called by the different schedule Elysia cron callbacks.
//function ma_dhan_send_scheduled_notifications($schedule) {
//  switch ($schedule) {
//    case 'daily':
//      $notification_field = 'field_notify_day';
//      break;
//    case 'weekly':
//      $notification_field = 'field_notify_week';
//      break;
//  }
//
//  // Get the following nodes that still have users to notify.
//  $query = new EntityFieldQuery();
//  $result = $query
//    ->addMetaData('account', user_load(1))
//    ->entityCondition('entity_type', 'node')
//    ->entityCondition('bundle', 'following_notification')
//    ->propertyCondition('status', NODE_PUBLISHED)
//    ->fieldCondition('field_all_users_notified', 'value', 0)
//    ->propertyOrderBy('changed', 'DESC')
//    ->execute();
//  if (isset($result['node']) && count($result['node'])) {
//    $successful_sends = [];
//    $aggregated_fcs_all_users = [];
//    foreach (array_keys($result['node']) as $nid) {
//      $notification_w = entity_metadata_wrapper('node', $nid);
//
//      // Get users to send to.
//      $users_to_send_to = $notification_w->field_notify_immediately->raw() ? $notification_w->field_notify_immediately->raw() : [];  // We start with all immediate notifications that have not yet gone out. This happens if a user was following a node on a schedule, the node was then updated before the schedule was fired, and then user changed their schedule to immediate (either on the node or by switching to default wherein their default is immediate). This ensures those notifications still get sent, during the next scheduled send (ie. no later than daily).
//      $users_to_send_to = array_merge($users_to_send_to, $notification_w->{$notification_field}->raw() ? $notification_w->{$notification_field}->raw() : []);
//      $users_to_send_to = array_diff($users_to_send_to, $notification_w->field_users_notified->raw() ? $notification_w->field_users_notified->raw() : []); // Do not send to users already notified.
//      $users_to_send_to = array_unique($users_to_send_to); // There never should be duplicates, but just in case.
//
//      if (count($users_to_send_to)) {
//        // Get the FC
//        $latest_fc = $notification_w->field_notification_email->count();
//        if ($latest_fc) { // This can be 0 from development debugging. Ultimately this should be able to be removed.
//          $fc = $notification_w->field_notification_email[$latest_fc - 1]->value();
//          // Add the FC for each user to send to.
//          foreach ($users_to_send_to as $user_to_send_to) {
//            $aggregated_fcs_all_users[$user_to_send_to][$nid] = $fc;
//          }
//        }
//      }
//
//    }
//
//    // Send the aggregate email(s), one per user.
//    foreach ($aggregated_fcs_all_users as $uid => $fc_items) {
//      $bodies = ["This is your " . $schedule . " digest of notifications for " . variable_get('site_name') . ". You may manage these notifications at: " . $GLOBALS['base_url'] . "/user/" . $uid . "/following"];
//      $following_nids = [];
//      foreach ($fc_items as $following_nid => $fc_item) {
//        $following_nids[] = $following_nid;
//        $bodies[] = $fc_item->field_notification_body[LANGUAGE_NONE][0]['value'];
//      }
//      $body = implode("\n_____________________________________________________________________________\n\n", $bodies); // 77 chars wide
//      $params = [
//        'subject' => 'Your ' . $schedule . ' notifications digest for ' . variable_get('site_name') . '.',
//        'body' => $body,
//      ];
//      $user = user_load($uid);
//      $result = drupal_mail('ma_dhan', 'collab_notification', $user->mail, language_default(), $params);
//      if ($result['result']) { // This doesn't guarantee much but it's better than nothing.
//        $successful_sends[$uid] = $following_nids;
//      }
//    }
//
//    // Update the Following nodes field_users_notified and then field_all_users_notified
//    $nids_to_update = [];
//    foreach ($successful_sends as $uid => $following_nids) {
//      foreach ($following_nids as $following_nid) {
//        $nids_to_update[$following_nid][] = $uid;
//      }
//    }
//    foreach ($nids_to_update as $nid_to_update => $users_emailed) {
//      $notification_w = entity_metadata_wrapper('node', $nid_to_update);
//      $users_notified = array_unique(array_merge($notification_w->field_users_notified->raw(), $users_emailed));
//      $notification_w->field_users_notified->set($users_notified);
//      $notification_w->save();
//      ma_dhan_update_field_all_users_notified($notification_w);
//    }
//
//  }
//}
//
///**
// * Helper function to get the following NID given child NID
// */
//function ma_dhan_get_following_nid($child_nid) {
//  $query = new EntityFieldQuery();
//  $result = $query
//    ->addMetaData('account', user_load(1))
//    ->entityCondition('entity_type', 'node')
//    ->entityCondition('bundle', 'following_notification')
//    ->propertyCondition('status', NODE_PUBLISHED)// or else it will retrieve node references for deleted DH items
//    ->fieldCondition('field_following_content', 'target_id', $child_nid)
//    ->execute();
//  return reset($result['node'])->nid;
//}

/**
 * Helper function to return if node is a Community or a CP.
 */
function ma_dhan_is_cp_or_comm($node) {
  if (in_array($node->type, ['community', 'cultural_protocol_group'])) {
    return TRUE;
  }
}
