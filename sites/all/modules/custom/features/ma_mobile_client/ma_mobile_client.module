<?php

/**
 * @file
 * Code for the Mukurtu Mobile Client feature.
 */

include_once 'ma_mobile_client.features.inc';

/**
 * Implements hook_menu().
 */
function ma_mobile_client_menu() {
  $items = [];

  $items['mukurtu-mobile'] = [
    'title' => 'Configure Mukurtu Mobile',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_mobile_client_admin_config'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  ];

  $items['node/%node/mobile-sync-toggle/%'] = [
    'page callback' => 'ma_mobile_client_toggle_sync_node',
    'page arguments' => array(1, 3),
    'access callback' => 'user_is_logged_in',
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
  ];

  $items['mobile/login/%/%/%'] = array(
    'title' => 'Mobile browser login',
    'page callback' => 'ma_mobile_client_browser_login',
    'page arguments' => array(2, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Mukurtu Mobile admin config form.
 * Linked from Dashboard.
 */
function ma_mobile_client_admin_config($form, $form_state) {

  $form['mukurtu_mobile_enabled'] = [
    '#type' => 'checkbox',
    '#title' => t('Enable access to the site via the Mukurtu Mobile app.'), // TODO: link to the app here.
    '#default_value' => variable_get ('mukurtu_mobile_enabled', 0),
  ];

  ////
  // Viewable content types table
  ////

  $ordered_types = variable_get('mm_viewable_types', []);
  uasort($ordered_types, 'drupal_sort_weight');
  $node_types = node_type_get_names();

  // If a node type has been added since var mm_viewable_types was last set
  // (meaning it wasn't saved to the mm_viewable_types var in this form nor in a hook_update or hook_install when the type was created)
  // then we need to ensure it gets added to this form, but at the bottom.
  foreach ($node_types as $type => $type_name) {
    if (!array_key_exists($type, $ordered_types)) {
      if (!isset($highest_weight)) {
        $highest_weight = end($ordered_types)['weight'] ? end($ordered_types)['weight'] : 0;
      }
      $highest_weight += 10;
      $ordered_types[$type] = [
        'viewable' => 0,
        'weight' => $highest_weight,
      ];
    }
  }

  $form['viewable'] = [
    '#type' => 'fieldset',
    '#title' => t('Viewable Content Types'),
    'help_text' => [
      // TODO change "View Content" text to what it actually is in the app.
      '#markup' => 'Check the content types which can be viewed within the Mukurtu Mobile app.<br/>Content types in <span class="linethrough">strikethrough</span> either need a Mukurtu Mobile view mode, or have paragraph fields which need a Mukurtu Mobile view mode, before they will work.<br/>Use the arrows to drag the content types into the order that they will display in the View Content page in the app.',
    ],
    'mm_viewable_types' => [
      '#tree' => TRUE,
      '#theme' => 'mm_viewable_types_table',
    ],
  ];

  foreach ($ordered_types as $node_type => $node_type_properties) {

    // Determine if a content type has a Mukurtu Mobile view mode.
    $view_modes = field_view_mode_settings('node', $node_type);
    $available = isset($view_modes["mukurtu_mobile"]) ? TRUE : FALSE;
    $fields = field_info_instances('node', $node_type);
    if ($available) {
      // Also need to make sure any of its Paragraph fields have a Mukurtu Mobile view mode as well.
      foreach ($fields as $field) {
        if (isset($field["display"]["mukurtu_mobile"]["module"]) && $field["display"]["mukurtu_mobile"]["module"] == 'paragraphs') {
          $allowed_bundles = array_keys($field["settings"]["allowed_bundles"]);
          if (count($allowed_bundles) > 1) {
            // TODO: handle this if it ever arises.
          }
          $paragraph_view_modes = field_view_mode_settings('paragraphs_item', $allowed_bundles[0]);
          if (is_null($paragraph_view_modes["mukurtu_mobile"])) {
            $available = FALSE;
            break;
          }
        }
      }
    }

    $form['viewable']['mm_viewable_types'][$node_type] = [
      'viewable' => [
        '#type' => 'checkbox',
        '#default_value' => $node_type_properties['viewable'],
        '#available' => $available, // Items that are not available will get a linethrough during render.
      ],
      'label' => [
        '#type' => 'item',
        '#markup' => $node_types[$node_type],
      ],
      'weight' => [
        '#type' => 'textfield',
        '#default_value' => $node_type_properties['weight'],
        '#size' => 3,
        '#attributes' => ['class' => ['item-row-weight']],
      ],
    ];
  }

  ////
  // Creatable content types table
  ////

  $ordered_types = variable_get('mm_creatable_types', []);
  uasort($ordered_types, 'drupal_sort_weight');
  $node_types = node_type_get_names();

  // If a node type has been added since var mm_creatable_types was last set
  // (meaning it wasn't saved to the mm_creatable_types var in this form nor in a hook_update or hook_install when the type was created)
  // then we need to ensure it gets added to this form, but at the bottom.
  foreach ($node_types as $type => $type_name) {
    if (!array_key_exists($type, $ordered_types)) {
      if (!isset($highest_weight)) {
        $highest_weight = end($ordered_types)['weight'] ? end($ordered_types)['weight'] : 0;
      }
      $highest_weight += 10;
      $ordered_types[$type] = [
        'creatable' => 0,
        'weight' => $highest_weight,
      ];
    }
  }

  $form['creatable'] = [
    '#type' => 'fieldset',
    '#title' => t('Creatable Content Types'),
    'help_text' => [
      // TODO: change "Create Content" text to what it actually is in the app.
      '#markup' => 'Check the content types which can be created within the Mukurtu Mobile app.<br/>Use the arrows to drag the content types into the order that they will display in the Create Content page in the app.',
    ],
    'mm_creatable_types' => [
      '#tree' => TRUE,
      '#theme' => 'mm_creatable_types_table',
    ],
  ];

  foreach ($ordered_types as $node_type => $node_type_properties) {
    $form['creatable']['mm_creatable_types'][$node_type] = [
      'creatable' => [
        '#type' => 'checkbox',
        '#default_value' => $node_type_properties['creatable'],
      ],
      'label' => [
        '#type' => 'item',
        '#markup' => $node_types[$node_type],
      ],
      'weight' => [
        '#type' => 'textfield',
        '#default_value' => $node_type_properties['weight'],
        '#size' => 3,
        '#attributes' => ['class' => ['item-row-weight']],
      ],
    ];
  }

  return system_settings_form($form);
}

/**
 * Implements hook_theme().
 */
function ma_mobile_client_theme($existing, $type, $theme, $path) {
  $themes = array(
    'mm_viewable_types_table' => array(
      'render element' => 'element'
    ),
    'mm_creatable_types_table' => array(
      'render element' => 'element'
    ),
  );
  return $themes;
}

/**
 * Make the node types table rows draggable; the resulting order is used when listing the content types in the app.
 */
function theme_mm_viewable_types_table($vars) {
  $element = $vars['element'];
  drupal_add_tabledrag('mm_viewable_types_table', 'order', 'sibling', 'item-row-weight');

  $header = array(
    'viewable' => t('Viewable'),
    'label' => t('Content Type'),
    'weight' => t('Weight'),
  );

  $rows = array();
  foreach (element_children($element) as $key) {
    $row = array();
    $row['data'] = array();
    foreach ($header as $fieldname => $title) {
      $row['data'][] = drupal_render($element[$key][$fieldname]);
      $classes = ['draggable'];
      if (!$element[$key]["viewable"]["#available"]) {
        $classes[] = 'linethrough';
      }
      $row['class'] = $classes;
    }
    $rows[] = $row;
  }

  return theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => 'mm_viewable_types_table'),
  ));
}

/**
 * Make the node types table rows draggable; the resulting order is used when listing the content types in the app.
 */
function theme_mm_creatable_types_table($vars) {
  $element = $vars['element'];
  drupal_add_tabledrag('mm_creatable_types_table', 'order', 'sibling', 'item-row-weight');

  $header = array(
    'creatable' => t('Creatable'),
    'label' => t('Content Type'),
    'weight' => t('Weight'),
  );

  $rows = array();
  foreach (element_children($element) as $key) {
    $row = array();
    $row['data'] = array();
    foreach ($header as $fieldname => $title) {
      $row['data'][] = drupal_render($element[$key][$fieldname]);
      $row['class'] = array('draggable');
    }
    $rows[] = $row;
  }

  return theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => 'mm_creatable_types_table'),
  ));
}


/**
 * Add or Remove a node from a user's mukurtu mobile synced nodes list (via ajax link)
 */
function ma_mobile_client_toggle_sync_node($node, $color) {

  // This would only happen via someone intentionally trying to hack in (hitting the toggle URL).
  // Important because otherwise a node they can't access will sync to their phone.
  if (!node_access('view', $node)) {
    return;
  }

  // Save to the user the new list of synced nodes.
  global $user;
  $uw = entity_metadata_wrapper('user', $user);
  $synced_nodes = $uw->field_mm_sync->raw();
  if (($key = array_search($node->nid, $synced_nodes)) !== FALSE) {
    unset($synced_nodes[$key]);
  }
  else {
    $synced_nodes[] =  $node->nid;
  }
  $uw->field_mm_sync->set($synced_nodes);
  $uw->save();

  // Update the mobile sync icon link (image and tooltip) for this node via ajax.
  return array(
    '#type' => 'ajax',
    '#commands' => [ajax_command_replace('.mobile-sync-' . $node->nid, ma_mobile_client_generate_toggle_link($node, $color))],
  );

}


/**
 * Generate the link to sync/unsync a node for a user.
 */
function ma_mobile_client_generate_toggle_link($node, $color = '') {
  if (user_is_logged_in()) {

    // If viewing another user's profile page, do not render the sync icons for any of the items in the blocks.
    // (would be very confusing because the sync would happen for viewing user, though the nodes displayed are for the viewed user)
    if (arg(0) == 'user' && !ma_mobile_client_viewing_own_profile()) {
      return;
    }

    if (!$node->type) {
      $node->type = $node->node_type; // when called by the My Mukurtu Mobile Content view (as opposed to the DS field)
    }
    global $user;
    $uw = entity_metadata_wrapper('user', $user);
    $synced_nodes = $uw->field_mm_sync->raw();
    if (in_array($node->nid, $synced_nodes)) {
      $icon = "synced";
      $link_text = 'Remove this ' . node_type_get_name($node->type) . ' from your Mukurtu Mobile synced content.';
    }
    else {
      $icon = "unsynced";
      $link_text = 'Add this ' . node_type_get_name($node->type) . ' to your Mukurtu Mobile synced content.';
    }
    if (!$color) {
      switch (theme_get_setting('mukurtu_theme_color_scheme', 'mukurtu')) {
        case 'red-bone':
          $color = 'red';
          break;
        default:
          $color = 'blue';
      }
    }
    $classes = [
      'use-ajax',
      'mobile-sync-icon',
      'mobile-sync-' . $node->nid,
    ];
    return l('<img src="/sites/all/themes/mukurtu/images/icons/mobile-' . $icon . '-' . $color . '.png">', 'node/' . $node->nid . '/mobile-sync-toggle/' . $color, ['html' => TRUE, 'attributes' => ['class' => $classes, 'title' => $link_text]]);
  }

}

/**
 * Callback to a log a user into the mobile browser using the link obtained by the app from the one-time-login endpoint.
 * This is based on user_pass_reset().
 */
function ma_mobile_client_browser_login($uid, $timestamp, $hashed_pass) {
  global $user;
  if ($user->uid) {
    //    drupal_set_message(t('User is already logged in.'), 'error');
    drupal_goto();
  }
  else {
    $timeout = 60;
    $current = REQUEST_TIME;
    $users = user_load_multiple(array($uid), array('status' => '1'));
    if ($timestamp <= $current && $account = reset($users)) {
      if ($current - $timestamp > $timeout) {
        drupal_set_message(t('Login link expires after ' . $timeout . 'seconds.'), 'error');
        drupal_goto('');
      }
      elseif ($account->uid && $timestamp >= $account->login && $timestamp <= $current && $hashed_pass == user_pass_rehash($account->pass, $timestamp, $account->login, $account->uid)) {
        $user = $account;
        user_login_finalize();
        drupal_goto('');
      }
      else {
        drupal_set_message(t('Login link already used or invalid.'), 'error');
        drupal_goto('');
      }
    }
    else {
      drupal_access_denied();
      drupal_exit();
    }
  }
}


/**
 * Check if viewing own profile page.
 *
 * Used as the view perm for My Mukurtu Mobile Content, and also in ma_mobile_client_generate_toggle_link()
 * to hide the sync icon on the nodes in the other blocks (Community, Protocols) when not viewing own profile.
 */
function ma_mobile_client_viewing_own_profile() {
  global $user;
  if ($user->uid == arg(1)) {
    return TRUE;
  }
}


/**
 * Implements of hook_services_resources().
 */
function ma_mobile_client_services_resources() {
  $api = [

    'one_time_login' => [
      'operations' => [
        'retrieve' => [
          'help' => 'Retrieve a one-time-login URL for the currently authed user, to use to auth the user in the mobile browser',
          'callback' => '_ma_mobile_client_get_one_time_login',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
          ],
        ],
      ],
    ],

    'synced_nodes' => [
      'operations' => [
        'retrieve' => [
          'help' => "Retrieve a structured array of a user's list of synced nodes",
          'callback' => '_ma_mobile_client_get_user_synced_nodes',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
          ],
        ],
      ],
    ],

    'creatable_types' => [
      'operations' => [
        'retrieve' => [
          'help' => "Retrieve a list of content types for which nodes of that type can be created from the Mukurtu Mobile app",
          'callback' => '_ma_mobile_client_get_creatable_types',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
          ],
        ],
      ],
    ],

    'node_form_fields' => [
      'operations' => [
        'retrieve' => [
          'help' => "Retrieves the fields and their properties, and fieldgroups, of the passed content type for the current user, to be used by the app in constructing the form in React.",
          'callback' => '_ma_mobile_client_get_node_form_fields',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
            [
              'name' => 'type',
              'type' => 'string',
              'description' => 'Content type',
              'source' => ['path' => '1'],
              'optional' => FALSE,
            ],

          ],
        ],
      ],
    ],

    'viewable_types' => [
      'operations' => [
        'retrieve' => [
          'help' => "Retrieve a list of content types for which nodes of that type can be viewed from the Mukurtu Mobile app",
          'callback' => '_ma_mobile_client_get_viewable_types',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
          ],
        ],
      ],
    ],

    'node_view_fields' => [
      'operations' => [
        'retrieve' => [
          'help' => "Retrieves the fields and their properties, and fieldgroups, to be used by the app in constructing the node view in React.",
          'callback' => '_ma_mobile_client_get_node_view_fields',
          'access callback' => 'user_is_logged_in',
          'args' => [
            [
              'name' => 'fn',
              'type' => 'string',
              'description' => 'Function to perform',
              'source' => ['path' => '0'],
              'optional' => FALSE,
            ],
            [
              'name' => 'type',
              'type' => 'string',
              'description' => 'Content type',
              'source' => ['path' => '1'],
              'optional' => FALSE,
            ],

          ],
        ],
      ],
    ],

  ];

  return $api;
}


/**
 * Provide a one-time-login link.
 */
function _ma_mobile_client_get_one_time_login($fn) {
  global $user;
  $timestamp = REQUEST_TIME;
  return url("mobile/login/$user->uid/$timestamp/" . user_pass_rehash($user->pass, $timestamp, $user->login, $user->uid), array('absolute' => TRUE));
}


/**
 * Retrieve a NID list of a user's synced nodes, w/ last updated time, so that we don't try to sync unchanged nodes.
 */
function _ma_mobile_client_get_user_synced_nodes ($fn) {
  global $user;
  $uw = entity_metadata_wrapper('user', $user);
  $synced_nodes = $uw->field_mm_sync->value();
  $synced_nids = [];
  $viewable_types = _ma_mobile_client_get_viewable_types();

  foreach ($synced_nodes as $synced_node) {

    if (!array_key_exists($synced_node->type, $viewable_types)) {
      continue; // Just in case user hacked to the form submission to get an invalid node as one to sync, or if an admin changed the valid vieawwable types subsequent to it being added.
    }

    // Add the node.
    if (node_access('view', $synced_node)) { // Check to make sure the user can view the node. This might not be the case if the CP on the node was changed after the user had set it to be synced.
      $synced_nids[$synced_node->type][$synced_node->nid]['last_updated'] = $synced_node->changed;
      $synced_nids[$synced_node->type][$synced_node->nid]['editable'] = node_access('update', $synced_node) ? TRUE: FALSE;
    }

    // For all the entity and node refs in the node, add those nodes to be synced as well.
    $synced_nids = _ma_mobile_client_add_ref_fields_to_sync_nodes($synced_node, $synced_nids);
  }

  return $synced_nids;
}


/**
 * For all the entity and node refs in the node, add those nodes to be synced as well.
 * We are going one-level deep*, so entity ref'ed nodes get synced, but entity ref'ed nodes of entity ref'ed nodes do not get synced.
 * Entity-ref'ed nodes are *not* marked as synced to the user, or else their own entity refs would then get synced; this is just
 * so that when viewing the parent node, the user can see its immediate children in the ref fields.
 *
 * * except for entity refs that are in $go_one_level_deeper. For these, the children get their own entity refs synced too.
 */
function _ma_mobile_client_add_ref_fields_to_sync_nodes($synced_node, $synced_nids) {
  static $ref_fields;
  $ref_fields = array_merge(field_read_fields(array('type' => 'node_reference')), field_read_fields(array('type' => 'entityreference')));
  static $go_one_level_deeper;
  $go_one_level_deeper = ['field_unit_lessons'];
  $snw = entity_metadata_wrapper('node', $synced_node);
  foreach ($ref_fields as $ref_field => $ref_field_properties) {
    if (isset($snw->{$ref_field}) && count($snw->{$ref_field}->raw())) {
      foreach ($snw->{$ref_field}->raw() as $reffed_nid) {
        $reffed_node = node_load ($reffed_nid);
        if (node_access('view', $reffed_node)) { // Check to make sure the user can view the reffed node.
          $synced_nids[$reffed_node->type][$reffed_node->nid]['last_updated'] = $reffed_node->changed;
          $synced_nids[$reffed_node->type][$reffed_node->nid]['editable'] = node_access('update', $reffed_node) ? TRUE: FALSE;
          // Go deeper for certain entity refs.
          if (in_array($ref_field, $go_one_level_deeper)) {
            $synced_nids = _ma_mobile_client_add_ref_fields_to_sync_nodes($reffed_node->nid, $synced_nids);
          }
        }
      }
    }
  }
  return $synced_nids;
}


/**
 * Retrieve a list of content types that are creatable by the app.
 */
function _ma_mobile_client_get_creatable_types ($fn = NULL) {
  $ordered_types = variable_get('mm_creatable_types', []);
  uasort($ordered_types, 'drupal_sort_weight');
  $node_types = node_type_get_types();
  $creatable_types = [];
  foreach ($ordered_types as $node_type => $node_type_properties) {
    if ($node_type_properties['creatable']) {
      $creatable_types[$node_type] = [
        'label' => $node_types[$node_type]->name,
        'description' => $node_types[$node_type]->description
      ];
    }
  }
  return $creatable_types;
}


/**
 * Retrieve a list of content types that are viewable by the app.
 */
function _ma_mobile_client_get_viewable_types ($fn = NULL) {
  $ordered_types = variable_get('mm_viewable_types', []);
  uasort($ordered_types, 'drupal_sort_weight');
  $node_types = node_type_get_types();
  $viewable_types = [];
  foreach ($ordered_types as $node_type => $node_type_properties) {
    if ($node_type_properties['viewable']) {
      $viewable_types[$node_type] = [
        'label' => $node_types[$node_type]->name,
        'description' => $node_types[$node_type]->description
      ];
    }
  }
  return $viewable_types;
}


/**
 * Retrieves the fields and their properties, and fieldgroups, of the passed content type for the current user, to be used by the app in constructing the form in React.
 */
function _ma_mobile_client_get_node_form_fields ($fn, $content_type) {

  if (!node_type_get_type($content_type)) {
    return 'Content type ' . $content_type . ' does not exist';
  }
  if (!key_exists($content_type, _ma_mobile_client_get_creatable_types())) {
    return 'Content type ' . $content_type . ' exists, but is not a valid app-creatable type.';
  }

  // Get the node form for this user and this content type.
  module_load_include('inc', 'node', 'node.pages');
  global $user;
  $node = new stdClass;
  $node->uid = $user->uid;
  $node->type = $content_type;
  $node->language = LANGUAGE_NONE;
  $node_form = drupal_get_form($content_type. '_node_form', $node);

  // Build $fields_and_fieldgroups out of the node form fields (skipping the ones we don't want), body, title, and the field groups.
  $fields_and_fieldgroups = [];
  $skip_fields = [
    'field_book_children',
    'field_book_parent',
    'field_pre_actions',
    'oggroup_fieldset',
  ];
  $special_fields = [
    'title',
    'body',
    '#groups',
    '#group_children',
    'group_access',
    'group_register',
    'og_roles_permissions',
    'og_group_ref',
  ];
  foreach ($node_form as $key => $value) {
    if (!in_array($key, $skip_fields) AND (in_array($key, $special_fields) OR substr($key, 0, 6) == 'field_')) {

      // Custom handling per field.
      switch ($key) {

        case "og_group_ref":
          $options = [];
          $communities = _ajax_get_community_dropdown_options([], FALSE);
          foreach ($communities as $community_nid => $community_name) {
            if ($community_nid) {
              $options [$community_name] = _ajax_get_protocol_by_community_dropdown_options($community_nid, [], FALSE);
            }
          }
          $value[LANGUAGE_NONE]["#options"] = $options;
          $value[LANGUAGE_NONE]["#required"] = ma_cultural_protocol_node_type_must_have_cp($content_type);

          break;

      }

      // Set the field.
      $fields_and_fieldgroups[$key] = $value;

    }
  }

  // Custom handling per content type.
  switch ($content_type) {
    case 'digital_heritage':
      break;
  }

  // Return the form.
  return $fields_and_fieldgroups;

}


/**
 * Retrieves the fields and their properties, and fieldgroups, to be used by the app in constructing the node view in React.
 *
 * TODO: this works with fields within fieldgroups, and with paragraphs within fieldsgroups.
 * But handling would need to be added for any of the following scenarios, if they arise in a new content type:
 * - fieldgroups within fieldgroups
 * - fieldsgroups within paragraphs
 */
function _ma_mobile_client_get_node_view_fields ($fn, $content_type) {

  if (!node_type_get_type($content_type)) {
    return 'Content type ' . $content_type . ' does not exist';
  }
  if (!key_exists($content_type, _ma_mobile_client_get_viewable_types())) {
    return 'Content type ' . $content_type . ' exists, but is not a valid app-viewable type.';
  }

  $structured_view = [];

  // Add fieldgroups to the structured view.
  $field_groups = field_group_info_groups('node', $content_type, 'mukurtu_mobile');
  $all_field_group_fields = [];
  foreach ($field_groups as $field_group => $field_group_properties) {
    $structured_view[$field_group] = ['type' => 'fieldgroup', 'label' => $field_group_properties->label, 'weight' => $field_group_properties->weight];
    if (count($field_group_properties->children)) {
      foreach ($field_group_properties->children as $child) {
        $all_field_group_fields[$child] = $field_group;
      }
    }
  }

  // Add fields to the structured view.
  $field_info = field_info_instances('node', $content_type);
  foreach ($field_info as $field => $field_properties) {
    $field_array = _ma_mobile_client_build_field_arrays_from_field_properties($field_properties);

    // For paragraphs, loop through its bundle fields and add them as fields within the paragraph.
    if (isset($field_properties['display']['mukurtu_mobile']["module"]) AND $field_properties['display']['mukurtu_mobile']["module"] == 'paragraphs') {
      $allowed_bundles = array_keys($field_properties["settings"]["allowed_bundles"]);
      if (count($allowed_bundles) > 1) {
        return 'Error: ' . $field . ' has more than 1 allowed bundle. _ma_mobile_client_get_node_view_fields() needs to be updated for this.';
      }
      $paragraph_fields = field_info_instances('paragraphs_item', $allowed_bundles[0]);
      foreach ($paragraph_fields as $paragraph_field => $paragraph_field_properties) {
        $paragraph_field_array = _ma_mobile_client_build_field_arrays_from_field_properties($paragraph_field_properties);
        $field_array['fields'][$paragraph_field] = $paragraph_field_array;
      }
    }

    // Fields within fieldgroups get added here.
    if (array_key_exists($field, $all_field_group_fields)) {
      $structured_view[$all_field_group_fields[$field]]['fields'][$field] = $field_array;
    }
    // Fields not within fieldgroups get added here.
    else {
      $structured_view[$field] = $field_array;
    }
  }

  // Sort the fields and fieldgroups, and the fields within fieldgroups, according to their weight.
  uasort($structured_view, 'drupal_sort_weight');
  foreach ($structured_view as $name => $properties) {
    if (isset($properties['fields'])) {
      uasort ($structured_view[$name]['fields'], 'drupal_sort_weight');
    }
  }

  // Return the structured view.
  return $structured_view;
}

/**
 * Called from _ma_mobile_client_get_node_view_fields().
 * Broken out into a separate function because it can be called within a nested loop.
 */
function _ma_mobile_client_build_field_arrays_from_field_properties($field_properties) {
  $view_mode_properties = $field_properties['display']['mukurtu_mobile'];
  unset ($field_properties['display']);
  return[
    'type' => 'field',
    'label' => $field_properties['label'],
    'weight' => $view_mode_properties['weight'],
    'view_mode_properties' => $view_mode_properties,
    'other_properties' => $field_properties
  ];
}


/**
 * Called from hook_update and hook_install to set to the default Mukurtu Mobile types
 */
function ma_mobile_client_set_default_types() {

  $ordered_viewable_types = ['digital_heritage', 'dictionary_word', 'word_list', 'unit_plan', 'community', 'cultural_protocol_group', 'person', 'personal_collection', 'collection'];
  $default_viewable_types = [];
  $weight = 0;
  foreach ($ordered_viewable_types as $ordered_viewable_type) {
    $weight += 10;
    $default_viewable_types[$ordered_viewable_type] = [
      'viewable' => 1,
      'weight' => $weight,
    ];
  }
  variable_set('mm_viewable_types', $default_viewable_types);
  
  $ordered_creatable_types = ['digital_heritage', 'dictionary_word', 'word_list', 'community', 'cultural_protocol_group', 'person', 'personal_collection'];
  $default_creatable_types = [];
  $weight = 0;
  foreach ($ordered_creatable_types as $ordered_creatable_type) {
    $weight += 10;
    $default_creatable_types[$ordered_creatable_type] = [
      'creatable' => 1,
      'weight' => $weight,
    ];
  }
  variable_set('mm_creatable_types', $default_creatable_types);
  
}
