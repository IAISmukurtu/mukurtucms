<?php
/**
 * @file
 * Code for the Mukurtu Core feature.
 */

include_once('ma_core.features.inc');

/**
 * Implementation of hook_init().
 */
function ma_core_init() {

  // Add the JS for jquery_ui_tooltips. Simply use the class "jquery_ui_tooltip" on any title attribute to use this
  drupal_add_js(drupal_get_path('module', 'ma_core') . '/js/jquery_ui_tooltips.js');

}

/**
 * Implements hook_user_login
 */
function ma_core_user_login(&$edit, $account) {

  //// Redirect user on login

  $current_path = current_path();

  // Do not redirect when user is logged in during profile installation, as more work needs to complete first
  if ($_GET['profile']) {
    return;
  }
  // Do not redirect when not coming from the login page, eg.
  // 1. if path is user/redirect, user is performing a password reset, as we do not want to override the redirect to password change form
  // 2. if this is a Mukurtu Mobile login to the services endpoint (see https://www.drupal.org/node/2394235)
  elseif ($current_path <> 'user' AND $current_path <> 'user/login') {
    return;
  }

  global $user;
  if (array_intersect(array('administrator', 'Mukurtu Administrator'), $user->roles)) {
    drupal_goto('dashboard');
  }
  else {
    drupal_goto(); // Non-admin users go to front page
  }
}

/**
 * Get NIDs from an array of nodes
 */
function ma_core_get_nids_from_array_of_nodes ($nodes = NULL) {
  $nids = array();
  if ($nodes) {
    foreach ($nodes as $node) {
      $nids[] = $node->nid;
    }
  }
  return $nids;
}

/**
 * Implements hook_views_pre_view().
 */
function ma_core_views_pre_view(&$view, &$display_id, &$args) {
  if ($view->name == 'group_members') {

    // Hide the manage/add members links in footer unless user can admin this group.
    if (is_numeric(arg(1))) {
      $gid = arg(1);
      if (!og_user_access('node', $gid, 'manage members')) {
        $view->set_item_option('block_1', 'footer', 'area', 'content', NULL);
      }
    }
  }
}

/**
 * Implements hook_views_pre_render().
 */
function ma_core_views_pre_render(&$view) {
  if ($view->name == 'group_members') {
    if (is_numeric(arg(1))) {
      $gid = arg(1);

      // Add the user role(s) after the user names. This can't quite be done in view config alone.
      $results = &$view->result;
      $roles_order = [
        'Community Manager',
        'Protocol Steward',
        'Contributor'
      ];
      foreach ($results as &$result) {
        $roles = og_get_user_roles('node', $gid, $result->uid);
        $formatted_roles = [];
        foreach ($roles as $role) {
          if ($role <> 'member') {
            $formatted_roles[] = ucwords ($role);
          }
        }
        if (count($formatted_roles)) {
          usort ($formatted_roles, "ma_core_sort_og_roles");
          $result->users_name = $result->users_name . ' (' . implode(', ', $formatted_roles) . ')';
        }
      }

    }
  }
}

/**
 * Helper function to sort the OG roles so that Protocol Steward is listed ahead of Contributor.
 */
function ma_core_sort_og_roles($leftItem, $rightItem){
  $order =  $roles_order = [
    'Community Manager',
    'Protocol Steward',
    'Contributor'
  ];

  $flipped = array_flip($order);

  $leftPos = $flipped[$leftItem];
  $rightPos = $flipped[$rightItem];
  return $leftPos >= $rightPos;
}

/**
 * Helper function based on og_extras_get_users_by_roles,
 * but takes role name instead of ID (thus also requiring group bundle param),
 * and returns user objects instead of raw query results.
 */
function ma_core_og_get_users_per_role_and_group ($role_name, $group_bundle, $gid) {
  if ($rid = array_search ($role_name, og_roles('node', $group_bundle, $gid))) {
    $query = db_select('og_users_roles', 'og_users_roles');
    $query->fields('og_users_roles', array('uid'))
      ->condition('gid', $gid)
      ->condition('rid', array ($rid), 'IN')
    ;
    if ($results = $query->execute()
      ->fetchAll()) {
      $uids = array();
      foreach ($results as $result) {
        $uids[] = $result->uid;
      }
      return user_load_multiple ($uids);
    }
  }
}

/**
 * Get all users of a group
 */
function ma_core_og_get_uids_in_group($gid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'user')
    ->fieldCondition('og_user_node', 'target_id', $gid);
  if ($results = $query->execute()) {
    $uids = array_keys($results['user']);
    return $uids;
  }
}

/**
 * Get all users of a group
 */
function ma_core_og_get_users_in_group($gid) {
  $uids = ma_core_og_get_uids_in_group($gid);
  if (count($uids)) {
    return user_load_multiple(ma_core_og_get_uids_in_group($gid));
  }
}


/**
 * Helper function to load users by core role.
 */
function ma_core_get_users_per_role ($role_name) {
  if ($role = user_role_load_by_name($role_name)) {
    $query = 'SELECT DISTINCT(ur.uid)  FROM {users_roles} AS ur WHERE ur.rid = (:rid)';
    $result = db_query($query, [':rid' => $role->rid]);
    $uids = $result->fetchCol();
    return user_load_multiple($uids);
  }
}

/**
 * Implements hook_menu().
 */
function ma_core_menu() {

  $items = array();
  // Empty home (front) page, added onto via context
  $items['home'] = array(
    'page callback' => 'ma_core_blank_page_callback',
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
  );

  // Release Notes page
  $version = ma_core_get_version();
  $items['release-notes'] = array(
    'title' => t($version . ' Release Notes'),
    'description' => 'Mukurtu Release Notes',
    'page callback' => 'ma_core_release_notes',
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 20,
  );
  return $items;
}

/**
 * Display the content for your blank page.
 */
function ma_core_blank_page_callback() {
  return ' ';
}

/**
 * Menu callback; Mukurtu Release Notes
 */
function ma_core_release_notes () {

  $file = nl2br(file_get_contents('VERSION.md'));
  return check_markup($file, 'markdown');
}


/**
 * Explodes a string of tags into an array.
 * Tweaked drupal_explode_tags that a) uses semicolon instead of comma as delimter, and b) no special handling (ie. not an escape) for quotes
 **/
function ma_core_taxonomy_explode_tags($tags) {
  $regexp = '%(?:^|;\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^;]*))%x';
  preg_match_all($regexp, $tags, $matches);
  $typed_tags = array_unique($matches[1]);

  $tags = array();
  foreach ($typed_tags as $tag) {
    $tag = trim($tag);
    if ($tag != "") {
      $tags[] = $tag;
    }
  }

  return $tags;
}

/**
 * Get the version from first line of version.md
 */
function ma_core_get_version() {

  $version_path = DRUPAL_ROOT . '/VERSION.md';
  if (file_exists($version_path)) {
    if ($version_file = fopen($version_path, 'r')) {
      $version = trim(fgets($version_file));
      if ($version = strstr ($version, 'Mukurtu ')) {
        return $version;
      }
    }
  }
}


/**
 * Get a taxonomy term object from a term name in a vocab. Create one if the term doesn't yet exist.
 */
function ma_core_get_create_tax_term ($term_name, $vocab_name) {
  if ($term = taxonomy_get_term_by_name($term_name, $vocab_name)) {
    return current($term);
  }
  else {
    $term = new StdClass();
    $vocab = taxonomy_vocabulary_machine_name_load($vocab_name);
    $term->vid = $vocab->vid;
    $term->name = $term_name;
    taxonomy_term_save($term);
    return $term;
  }
}

/**
 * Implementation of HOOK_form_alter()
 */
function ma_core_form_alter(&$form, $form_state, $form_id) {

  // Duplicate a the node form action buttons at the top of the form.
  // Normally we could just duplicate the field here and set its weight,
  // but because our forms are managed in DS, the field needs to be created there
  // first, or else we can't move the field high enough on the form. So we create
  // a dummy Pre-Actions field (a boolean) in Manage Fields, and then rewrite it here,
  // simply duplicating the contents of form actions as they appear at bottom.
  if (isset($form['#node_edit_form']) AND $form['#node_edit_form']) {
    $form['field_pre_actions'] = $form['actions'];
    $form['field_pre_actions']['#weight'] = -5; // for those content types where the field layout is not in DS.
  }

  // Disable taxonomy term delete button for users that don't have edit rights to all referenced content
  if($form_id == 'taxonomy_form_term' && !$form_state['submitted']) {
      $tid = $form['#term']['tid'];
      $referenced_nodes = taxonomy_select_nodes($tid);

      if(!ma_core_can_delete_taxonomy_term($tid)) {
          $form['actions']['delete']['#disabled'] = TRUE;
          $form['actions']['delete']['#attributes'] = array(
              'title' => t('This term cannot be deleted because you do not have edit access to some content that references this term.')
          );
      }
  }

  // Add an extra warning to the term delete confirmation form
  if($form_id == 'taxonomy_form_term' && (isset($form_state['confirm_delete']) && $form_state['confirm_delete'])) {
      $message = "Deleting a term will also remove the term and all its children from all content that reference it.";
      $form['description']['#markup'] = $form['description']['#markup'] . '<br>' . t($message);
  }

}

/**
 * For a given taxonomy term ID, return if the user has edit rights to all referenced content
 */
function ma_core_can_delete_taxonomy_term($tid) {
    // Get nodes that reference this term
    $referenced_nodes = taxonomy_select_nodes($tid);

    // Also get nodes that reference child terms
    $child_terms = taxonomy_get_children($tid);
    if(!empty($child_terms)) {
        foreach($child_terms as $child_term) {
            $referenced_nodes = array_merge($referenced_nodes, taxonomy_select_nodes($child_term->tid));
        }
    }

    // Check edit access for all referenced content
    $can_delete = TRUE;
    if(count($referenced_nodes) > 0) {
        foreach($referenced_nodes as $referenced_nid) {
            if(!node_access('delete', $referenced_nid)) {
                $can_delete = FALSE;
                break;
            }
        }
    }

    return $can_delete;
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function ma_core_taxonomy_term_delete($term) {
    // Get nodes that reference that term
    $referenced_nodes = taxonomy_select_nodes($term->tid);
    if(count($referenced_nodes) > 0) {
        // Load each node and inspect each of their fields for the term.
        // Currently we are only inspecting taxonomy_term_reference fields, but in theory, other fields
        // such as entityreference fields, could also contain that term. We aren't hunting down those at
        // this time.
        foreach($referenced_nodes as $referenced_nid) {
            $node = node_load($referenced_nid);
            if($node) {
                $fields = field_info_instances('node', $node->type);
                foreach($fields as $field) {
                    $field_info = field_info_field($field['field_name']);
                    if($field_info['type'] == 'taxonomy_term_reference') {
                        $wrapper = entity_metadata_wrapper('node', $node);
                        $term_list = $wrapper->{$field['field_name']}->value();

                        // Remove term from content
                        foreach($term_list as $k => $t) {
                            if($t->tid == $term->tid) {
                                unset($term_list[$k]);
                                $wrapper->{$field['field_name']}->set($term_list);
                                $wrapper->save();
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * Implementation of hook_block_info().
 */
function ma_core_block_info() {
  $blocks['create_content'] = array(
    'info' => t('Create Content'),
  );
  return $blocks;
}

/**
 * Implementation of hook_block_view().
 */
function ma_core_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'create_content':
      $block['subject'] = t('Create Content');
      $block['content'] = ma_core_create_content_block();
      break;
  }
  return $block;
}

/**
 * The Create Content block which appears on the Community, CP, Calendar Section, Discussion Section, and Document Section node views.
 */
function ma_core_create_content_block() {

  $nid = arg(1);
  if (is_numeric($nid)) {
    $node = node_load($nid);

    switch ($node->type) {
      case 'community':
        $link_sources = [
          'cultural_protocol_group' => '?og_group_ref=' . $nid,
          'digital_heritage' => '/' . $nid,
        ];
        break;
      case 'cultural_protocol_group':
        $link_sources = [
          'digital_heritage' => '/' . $node->og_group_ref[LANGUAGE_NONE][0]['target_id']. '/' . $nid,
        ];
        if (module_exists('ma_collaboration_tools')) {
          foreach (ma_culturalprotocol_collab_parent_node_types() as $parent_type) {
            $link_sources[$parent_type] = '/' . $node->og_group_ref[LANGUAGE_NONE][0]['target_id'] . '/' . $nid . '?destination=node/' . arg(1) . '/last_tab';
          }
        }
        break;
      default:
        return; // Safeguard. This should never happen.
    }

    // Output the links
    $links = "";
    foreach ($link_sources as $target_type => $link_query) {
      $target_type_link = str_replace('_', '-', $target_type);
      if (og_user_access('node', $nid, 'create ' . $target_type . ' content')) {
        $links .= '<div class="view-content"><a href="' . '/node/add/' . $target_type_link . $link_query . '">Create ' . node_type_get_names()[$target_type] . '</a></div>';
      }
    }

    return $links;
  }
}

/**
 * Helper function recursively unset keys from an array.
 */
function recursive_unset(&$array, $unwanted_key) {
  unset($array[$unwanted_key]);
  foreach ($array as &$value) {
    if (is_array($value)) {
      recursive_unset($value, $unwanted_key);
    }
  }
}

/**
 * Helper function to recursively compare arrays, including associative keys.
 */
function array_diff_assoc_recursive($array1, $array2) {
  $difference=array();
  foreach($array1 as $key => $value) {
    if( is_array($value) ) {
      if( !isset($array2[$key]) || !is_array($array2[$key]) ) {
        $difference[$key] = $value;
      } else {
        $new_diff = array_diff_assoc_recursive($value, $array2[$key]);
        if( !empty($new_diff) )
          $difference[$key] = $new_diff;
      }
    } else if( !array_key_exists($key,$array2) || $array2[$key] !== $value ) {
      $difference[$key] = $value;
    }
  }
  return $difference;
}

/**
 * Custom breadcrumbs for Mukurtu
 */
function ma_core_menu_breadcrumb_alter(&$active_trail, $item) {
  // Return immediately if Mukurtu breadcrumbs are disabled
  if(variable_get('mukurtu_breadcrumbs_opt_out', FALSE)) {
    return;
  }

  $trail_keys = array_keys($active_trail);
  $i = end($trail_keys);

  // Keep track of where we are. For container type pages (browse pages, collections, dictionary, word lists)
  // we want to try and include breadcrumbs back to the origin
  // Grab the previous item. Currently we are only tracking one previous item.
  $past_item = NULL;
  if(isset($_SESSION['mukurtu_breadcrumb_item'])) {
    $past_item = $_SESSION['mukurtu_breadcrumb_item'];
  }

  // If we are on a possible container, store the item
  if(isset($item['page_arguments'][0]->type)) {
    switch($item['page_arguments'][0]->type) {
      case "community":
      case "collection":
      case "word_list":
        $_SESSION['mukurtu_breadcrumb_item']['item'] = $item;
        $_SESSION['mukurtu_breadcrumb_item']['trail'] = $active_trail[$i];
        $_SESSION['mukurtu_breadcrumb_item']['query_parameters'] = drupal_get_query_parameters();
        $past_item = NULL;
        break;
    }
  }
  // Capture browse pages
  if(is_string($item['page_arguments'][0])) {
    $_SESSION['mukurtu_breadcrumb_item']['item'] = $item;
    $_SESSION['mukurtu_breadcrumb_item']['trail'] = $active_trail[$i];
    $_SESSION['mukurtu_breadcrumb_item']['query_parameters'] = drupal_get_query_parameters();
    $past_item = NULL;
  }

  if(isset($item['page_arguments'][0]->type)) {
    // Some pages we don't want to mess with the breadcrumb
    // In that case, clear the past item
    if($item['page_arguments'][0]->type == 'page') {
      $past_item = NULL;
    }

    // At this point, we have information about the previous page that
    // we would like to include in the breadcrumbs
    if($past_item) {
      // Start by inserting the past item in the next to last breadcrumb slot
      $active_trail[$i + 1] = $active_trail[$i];
      $active_trail[$i] = $past_item['trail'];

      // The search pages are more complicated, we want to retain both
      // the exact page arguments and query parameters
      if(is_string($past_item['item']['page_arguments'][0]) &&
        stripos($past_item['item']['page_arguments'][0], '_browse') !== FALSE) {
        $href = $past_item['item']['path'];

        // Handle the page arguments
        if(count($past_item['item']['page_arguments']) > 1) {
          foreach(range(1, count($past_item['item']['page_arguments'])) as $delta) {
            $href .= "/{$past_item['item']['page_arguments'][$delta]}";
          }
        }

        // Update the breadcrumb, include the query parameters
        $breadcrumb_title = $past_item['item']['title'] != "" ? $past_item['item']['title'] . ' Results' : $past_item['trail']['link_title'] . ' Results';
        $active_trail[$i] = array(
          'title' => t($breadcrumb_title),
          'href' => $href, 'localized_options' => array('query' => $past_item['query_parameters'])
        );
      }
    } else {
      // If viewing a collection, add in a "Collections" breadcrumb
      if($item['page_arguments'][0]->type == 'collection') {
        $active_trail[$i + 1] = $active_trail[$i];
        $active_trail[$i] = array('title' => t('Collections'), 'href' => 'collections', 'localized_options' => array());
      }
    }
  }
}
