<?php
/**
 * @file
 * Code for the Mukurtu Import/Export Dublin Core feature.
 */

include_once 'ma_importexport_dc.features.inc';


/**
 * Implementation of hook_menu()
 */
function ma_importexport_dc_menu() {

  $items['import/digital-heritage-dc-file'] = array(
    'title' => 'Import Digital Heritage Dublin Core XML - File',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_importexport_dc_import_form_standalone'),
    'access arguments' => array('import digital_heritage_metadata feeds'),
  );

  $items['import/digital-heritage-dc-options'] = array(
    'title' => 'Import Digital Heritage Dublin Core XML - Options',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ma_importexport_dc_import_form_options'),
    'access arguments' => array('import digital_heritage_metadata feeds'),
  );

  return $items;
}

/**
 * Custom form for user to upload the XML.
 */
function ma_importexport_dc_import_form_standalone($form, $form_state) {

  $form['xml_file'] = array(
    '#type' => 'managed_file',
    '#title' => t('File'),
    '#description' => 'Select a Dublin Core XML file from your local system.',
    '#size' => 22,
    '#upload_location' => 'private://mukurtu_dc_xml_import',
    '#upload_validators' => array(
      'file_validate_extensions' => array('xml')
    ),
    '#default_value' => variable_get('dc_import_fid'),
    '#required' => TRUE,
  );

  $form['after_upload']['submit'] = [
    '#type' => 'submit',
    '#value' => t('Continue'),
  ];

  return $form;
}

/**
 * On submission, set the file FID to a var (to be used in the options form),
 * and redirect to the options form.
 */
function ma_importexport_dc_import_form_standalone_submit($form, $form_state) {
  variable_set('dc_import_xml_fid', $form_state['values']['xml_file']);
  drupal_goto('import/digital-heritage-dc-options');
}

/**
 * Custom form for the XML options.
 */
function ma_importexport_dc_import_form_options($form, $form_state) {

  $fid = variable_get('dc_import_xml_fid');
  if (!$fid) { // This should never happen.
    drupal_goto('import/digital-heritage-dc-standalone');
  }

  // Get the attributes (the fields) from the XML file to use for the GUID and Media options below.
  $file = file_load ($fid);
  $path_to_file = drupal_realpath($file->uri);
  $file_contents = file_get_contents($path_to_file);
  // Tried doing this with simplexml but it fails on test imports
  // (it's excessively sensitive to character formatting and xmlns specs).
  // Also tried using the DOM but it was overkill.
  $parser = xml_parser_create();
  xml_parse_into_struct($parser, $file_contents, $values, $index);
  xml_parser_free($parser);
  $attributes = array_map('strtolower', (array_keys($index)));
  $attributes = array_combine($attributes, $attributes);

  // GUID source checkboxes.
  $form['guid'] = array(
    '#type' => 'checkboxes',
    '#title' => 'GUID',
    '#description' => 'Select which field(s) to use for the GUID (globally unique identifier). Typically you would use "dc:identifier". But if this not unique in your XML, you need to use another field which is. If there is no such field, you can select multiple fields which will combine to create the GUID. Only choose as many as is required to create a unique value. Choose field(s) that will not be edited if the XML is re-imported later, because an edited GUID field will create a new, separate Digital Heritage item.',
    '#options' => $attributes,
    '#required' => TRUE,
  );
  if (isset($attributes['dc:identifier'])) {
    $form['guid']['#default_value'] = ['dc:identifier'];
  }

  // Media source radio.
  $form['media'] = array(
    '#type' => 'radios',
    '#title' => 'Media',
    '#description' => 'Select which field contains the reference to media for the Digital Heritage item. This is typically "dc:hasformat", or "dc:relation".',
    '#options' => $attributes,
    '#required' => TRUE,
  );
  if (isset($attributes['dc:hasformat'])) {
    $form['media']['#default_value'] = 'dc:hasformat';
  }
  elseif (isset($attributes['dc:relation'])) {
    $form['media']['#default_value'] = 'dc:relation';
  }

  // Custom protocol field.
  list ($form, $form_state) = mukurtu_protocol_field_custom_field($form, $form_state, NULL, TRUE);

  // Sharing settings radio.
  $sharing_options = [
    'any' => 'The imported Digital Heritage items will be viewable by members of ANY Protocols selected above (or all users if any of the Protocols are set to Open).',
    'all' => 'The imported Digital Heritage items will be viewable only by members of ALL Protocols selected above (or all users if all of the Protocols are set to Open).'
  ];
  $form['sharing'] = array(
    '#type' => 'radios',
    '#title' => 'Items Sharing Setting',
    '#options' =>   $sharing_options,
    '#default_value' => 'all',
    '#required' => TRUE,
  );

  // Import button
  $form['submit'] = [
    '#type' => 'submit',
    '#value' => t('Import'),
  ];

  // Add a validation handler.
  $form['#validate'][] = 'ma_importexport_dc_import_form_options_validate';

  // Return form.
  return $form;
}

/**
 * Submit handler for the options form.
 */
function ma_importexport_dc_import_form_options_validate($form, $form_state) {
  if ($form_state['triggering_element']['#type'] == 'submit') { // This validation function will fire after a community is added but before a protocol is added, which will fail validation. So check to make sure this is fired from the submit button first.
    if (!$form_state['values']['oggroup_fieldset'][0]['dropdown_second']) {
      form_set_error('', "At least one Community and Protocol needs to be selected.");
    }
  }
}

/**
 * Submit handler for the options form.
 */
function ma_importexport_dc_import_form_options_submit($form, $form_state) {

  // Set the options to be picked up by the importer.
  variable_set ('dc_import_options', $form_state['values']);

  // Load the Feeds Source object.
  $source = feeds_source('digital_heritage_dc');
  $fetcher_config = $source->getConfigFor($source->importer->fetcher);
  $file = file_load (variable_get('dc_import_xml_fid'));
  $fetcher_config['source'] = $file->uri;
  $fetcher_config['file'] = $file;
  // Set the source fetcher config.
  $source->setConfigFor($source->importer->fetcher, $fetcher_config);
  // Save the source.
  $source->save();
  // Do the import
  $source->startImport();
}

/**
 * Implements hook_feeds_after_parse().
 * Set the GUID and dc:hasformat field values according to their source as selected in the options form.
 * Note: this could also be done by altering the mapping, as in https://drupal.stackexchange.com/questions/254661/feeds-how-to-set-a-blank-source-value-programmatically,
 * but that method still requires updating the values individually in the targets_alter, so it's no
 * more efficient (and coding-wise less efficient) than just altering each value individually here in the after_parse.
 */
function ma_importexport_dc_feeds_after_parse(FeedsSource $source, FeedsParserResult $result) {
  if ($source->id == 'digital_heritage_dc') {

    $options = variable_get('dc_import_options');
    $guid_parts = [];
    foreach ($options['guid'] as $attribute) {
      if ($attribute) {
        $guid_parts[] = str_replace(':', '_', $attribute);
      }
    }
    foreach ($result->items as $i => $item) {
      $guid_values = [];
      foreach ($guid_parts as $guid_part) {
        $guid_values[] = $item[$guid_part];
      }
      $result->items[$i]['guid'] = implode(':', $guid_values);
      $result->items[$i]['dc:hasformat'] = $item[str_replace(':', '_', $options['media'])];
    }

  }
}

/**
 * Implements hook_feeds_presave().
 */
function ma_importexport_dc_feeds_presave(FeedsSource $source, $entity, $item) {
  if ($source->id == 'digital_heritage_dc') {

  }
}
