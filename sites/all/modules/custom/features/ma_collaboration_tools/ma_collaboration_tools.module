<?php
/**
 * @file
 * Code for the Mukurtu Collaboration Tools feature.
 */

include_once 'ma_collaboration_tools.features.inc';

/**
 * Implements hook_page_alter().
 *
 * When viewing a CP, if there are section pages for the CP that the user has view rights to, then show them as tabs, with the CP itself in the first tab.
 */
function ma_collaboration_tools_page_alter(&$data) {

  if (isset($data['content']['system_main']['nodes']) && !isset($data['content']['system_main']['term_heading']['term'])) {

    $array_keys = array_keys($data['content']['system_main']['nodes']);
    $cp_node = $data['content']['system_main']['nodes'][array_shift($array_keys)]["#node"];
    if ($cp_node && $cp_node->type == 'cultural_protocol_group') {
      $nids = element_children($data['content']['system_main']['nodes']);
      $nid = $nids[0];

      // Get all section pages referencing that are in this CP.
      $query = new EntityFieldQuery();
      $result = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', ma_collaboration_tools_parent_node_types(), 'IN')
        ->propertyCondition('status', NODE_PUBLISHED) // or else it will retrieve node references for deleted DH items
        ->fieldCondition('og_group_ref', 'target_id', $nid)
        ->execute();

      if (isset($result['node']) && count($result['node'])) {
        $tabs = [];
        $section_nodes = node_load_multiple(array_keys($result['node']));
        foreach ($section_nodes as $section_node) {
          if (node_access('view', $section_node)) { // Ensure user has view perms to this section page.
            $tabs[] = [
              'type' => 'node',
              'nid' => $section_node->nid,
              'view_mode' => 'full',
              'title' => $section_node->title,
              'hide_title' => 0,
            ];
          }
        }
        if (count($tabs)) {

          // Main CP tab
          $contents = '';

          // Add the CP local tasks within the tab content.
          // This is like what is being done in ma_digitalheritage_preprocess_node & ma_digitalheritage_community_record_local_tasks but with a lot less code.
          $local_tasks = menu_local_tasks()['tabs']['output'];
          if (count($local_tasks) > 1) {
            $local_tasks['#prefix'] = '<ul class="tabs--primary nav nav-tabs">';
            $local_tasks['#suffix'] = '</ul>';
            $contents .= drupal_render($local_tasks);
            // Set a flag to remove the CP local tasks from above the tabs, processed in ma_collaboration_tools_preprocess_page.
            $data['hide_node_local_tasks'] = 1;
          }

          // Add the CP node content to the first tab contents, and then build the first tab.
          $node_view = node_view($cp_node, 'full');
          $contents .= drupal_render($node_view);
          $tabs[] = [
            'contents' => $contents,
            'title' => 'Protocol',
            'hide_title' => 1,
            'weight' => -1,
          ];

          // Build the tabs object and render it as the output.
          $tab_settings = [
            'ajax' => 0,
            'default_tab' => 0,
            'title' => 'CP Tabs',
            'renderer' => 'quicktabs',
            'style' => 'Excel',
            'hide_empty_tabs' => 1,
          ];
          $built_tabs = quicktabs_build_quicktabs("community-record", $tab_settings, $tabs);
          $data['content']['system_main']['#markup'] = drupal_render($built_tabs);

        }
      }
    }
  }
}

/**
 * Overall map of the collab pages types, to be used by the helper functions below.
 */
function ma_collaboration_tools_collab_node_types_map() {
  return [
    'event' => ['parent' => 'calendar', 'ref_field' => 'field_event_calendar_section'],
    'oa_discussion_post' => ['parent' => 'discussion_space', 'ref_field' => ''],
    'oa_wiki_page' => ['parent' => 'document_library', 'ref_field' => ''],
  ];
}

/**
 * Get the collab child node types
 */
function ma_collaboration_tools_child_node_types() {
  return array_keys(ma_collaboration_tools_collab_node_types_map());
}

/**
 * Get the collab parent node types
 */
function ma_collaboration_tools_parent_node_types() {
  $parent_types = [];
  foreach (ma_collaboration_tools_collab_node_types_map() as $child_type => $child_type_props) {
    $parent_types[] = $child_type_props['parent'];
  }
  return $parent_types;
}

/**
 * Get the child type from the parent type.
 */
function ma_collaboration_tools_get_child_from_parent($parent_type) {
  foreach (ma_collaboration_tools_collab_node_types_map() as $child_type => $child_type_props) {
    if ($child_type_props['parent'] == $parent_type) {
      return $child_type;
    }
  }
}

/**
 * Get the child type ref field to its parent.
 */
function ma_collaboration_tools_get_child_ref_field_to_parent($child_type) {
  return ma_collaboration_tools_collab_node_types_map()[$child_type]['ref_field'];
}



/**
 * Implements hook_preprocess_page.
 */
function ma_collaboration_tools_preprocess_page(&$variables) {
  if(isset($variables['node']) && $variables['node']->type == 'cultural_protocol_group') {
    // If the local tasks are being displayed separately within the CP tab, then hide the default local tasks which appear above the tabs.
    if (isset($variables['page']['hide_node_local_tasks'])) {
      unset($variables['tabs']);
    }
  }
}

/**
 * Implements hook_node_view().
 */
function ma_collaboration_tools_node_view($node, $view_mode) {

  // Update the item privacy text on the Collab section pages node view, to make more sense in this context and to hide it if there is only one protocol.
  if ($view_mode == 'full' && in_array($node->type, ma_collaboration_tools_parent_node_types())) {
    if (count($node->content['og_group_ref'][0]['#items']) < 2) {
      unset($node->content['field_item_privacy_setting'][0]['#markup']);
    }
    else {
      if ($node->field_item_privacy_setting[LANGUAGE_NONE][0]['value'] == 'any') {
        $text = 'Item is shared with members that belong to ANY of the above Protocols.';
      }
      else {
        $text = 'Item is shared with members that belong to ALL the above Protocols.';
      }
      $node->content['field_item_privacy_setting'][0]['#markup'] = $text;
    }
  }

  if ($view_mode == 'full' && $node->type == 'event') {

    $date = &$node->content['field_oa_date'][0]['#markup'];

    // For events with a repeating date, add a field label "Next: " for the next event date. This provides info clarification, and makes the next date align with the repeating date description.
    if (strpos($date, '<div class="date-repeat-rule">') !== false) {
      $closing_div_pos = strpos ($date, '</div>') + 6;
      $rrdiv = substr($date, 0, $closing_div_pos);
      $rest = substr($date, $closing_div_pos);
      $date =$rrdiv  . '<div class="label-inline">Next:&nbsp;</div>' . $rest;
    }

  }
}


/**
 * DS custom field.
 *
 * Add content to collab parent link.
 */
function ma_collaboration_tools_add_content_to_section_link($entity) {
  $child_type = ma_collaboration_tools_get_child_from_parent($entity->type);
  $node_disp_name = node_type_get_names()[$child_type];
  $pronoun = 'a';
  if (in_array(strtolower($node_disp_name{0}), ['a','e','i','o','u'])) {
    $pronoun = 'an';
  }
  $child_type_path = str_replace('_', '-', $child_type);
  if (og_user_access_entity('create ' . $child_type . ' content', 'node', $entity)) {
    return l('Add ' . $pronoun . ' ' . $node_disp_name, 'node/add/' . $child_type_path . '/' . $entity->nid, [
      'query' => drupal_get_destination(),
    ]);
  }
}

/**
 * DS custom field.
 *
 * Edit collab section link.
 */
function ma_collaboration_tools_edit_collab_section_link($entity) {
  if (node_access('update', $entity)) {
    $node_disp_name = node_type_get_names()[$entity->type];
    return l('Edit ' . $node_disp_name, 'node/' . $entity->nid . '/edit');
  }
}


/**
 * Implements hook_node_presave().
 */
function ma_collaboration_tools_node_presave($node) {
  if (in_array($node->type, ma_collaboration_tools_child_node_types())) {

    // Copy the protocol, community, and item sharing field values for the child pages from their parent pages.
    $child_page_w = entity_metadata_wrapper('node', $node);
    $parent_page_w = entity_metadata_wrapper('node', $child_page_w->{ma_collaboration_tools_get_child_ref_field_to_parent($node->type)}->value());
    $child_page_w->field_item_privacy_setting->set($parent_page_w->field_item_privacy_setting->value());
    $protocols = $parent_page_w->og_group_ref->value();
    $protocol_nids = [];
    $community_nids = [];
    foreach ($protocols as $protocol) {
      $protocol_nids[] = $protocol->nid;
      $community_nids[] = $protocol->og_group_ref[LANGUAGE_NONE][0]['target_id'];
    }
    if (count($protocol_nids)) {
      $child_page_w->og_group_ref->set(array_unique($protocol_nids));
      $child_page_w->field_community_ref->set(array_unique($community_nids));
    }

  }
}

/**
 *  Implements hook_form_alter().
 */
function ma_collaboration_tools_form_alter(&$form, &$form_state, $form_id) {

  // On Collab child pages
  $node_type = str_replace('_node_form', '', $form_id, $count);
  if ($count && in_array($node_type, ma_collaboration_tools_child_node_types())) {

    // Adding a new collab page.
    if (is_null($form['nid']['#value'])) {

      // Prepopulate the reference to the section page with the argument from the URL.
      if (is_numeric(arg(3))) {
        $ref_field = ma_collaboration_tools_get_child_ref_field_to_parent($node_type);
        $form[$ref_field][LANGUAGE_NONE]['#value'] = arg(3);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * Taken from OA.
 */
function ma_collaboration_tools_field_formatter_info() {
  return array(
    'events_date_formatter' => array(
      'label' => t('Open Atrium Date Formatter'),
      'field types' => array('datestamp'),
    ),
  );
}


/**
 * Implements hook_field_formatter_view().
 *
 * Taken from OA.
 */
function ma_collaboration_tools_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  if ($display['type'] == 'events_date_formatter') {

    $event_info = ma_collaboration_tools_find_next_event($items);
    $event = $event_info['event'];

    // Create Date objects from item values.
    $timezone_object = date_default_timezone_object();

    $start_date = new DateObject($event['value'], $event['timezone_db'], DATE_FORMAT_UNIX);
    $start_date->setTimezone($timezone_object);

    $end_date = new DateObject($event['value2'], $event['timezone_db'], DATE_FORMAT_UNIX);
    $end_date->setTimezone($timezone_object);

    // Create an array of month / day information for ease of use.
    $dates = array(
      'start' => array(
        'day' => date_format_date($start_date, 'custom', 'd'),
        'month' => date_format_date($start_date, 'custom', 'M'),
      ),
      'end' => array(
        'day' => date_format_date($end_date, 'custom', 'd'),
        'month' => date_format_date($end_date, 'custom', 'M'),
      ),
    );

    // For now always use the start date. We may add multi-day event to the
    // widget at some point in the future.
    $day = $dates['start']['day'];
    $month = $dates['start']['month'];
    $element[0] = array(
      '#markup' => theme('event_date', array('month' => $month, 'day' => $day)),
    );
  }
  return $element;
}

/**
 * Find the next upcoming event or the last event in a series.
 *
 * @param  array $items
 *   An array of dates attached to a field.
 * @return array
 *   An array, keyed by delta and event.
 *
 * Taken from OA.
 */
function ma_collaboration_tools_find_next_event($items) {
  // Set some base params we'll need.
  $now = time();
  $event = NULL;
  $event_delta = NULL;
  $next_event = NULL;
  $last_event = NULL;
  $next_event_delta = NULL;
  $last_event_delta = NULL;
  $diff = 0;

  // Loop through all events.
  foreach ($items as $delta => $date) {
    // If event is a future date.
    if ($date['value'] >= $now) {
      // That happens before the last found future event
      if ($diff == 0 || ($date['value'] - $now) < $diff) {
        // Set it as the currently found next event, and update the difference.
        $diff = $date['value'] - $now;
        $next_event = $date;
        $next_event_delta = 0;
      }
    }
    // Determine if this is the last event in the series.
    else if (empty($last_event) || ($date['value'] > $last_event['value'])) {
      $last_event = $date;
      $last_event_delta = $delta;
    }
  }

  // If there is no future event we'll use the last occurrence.
  if (empty($next_event)) {
    $event = $last_event;
    $event_delta = $last_event_delta;
  }
  else {
    $event = $next_event;
    $event_delta = $next_event_delta;
  }

  return array(
    'delta' => $event_delta,
    'event' => $event,
  );
}

/**
 * Implements hook_theme()
 *
 * Taken from OA. Simplified.
 */
function ma_collaboration_tools_theme() {

  $theme = array(
    'event_date' => array(
      'template' => 'event-date',
      'path' => drupal_get_path('module', 'ma_collaboration_tools') . '/templates',
      'variables' => array(
        'month' => NULL,
        'day' => NULL,
      ),
    ),
  );
  return $theme;
}


/**
 * Custom follow/unfollow field.
 */
function ma_collaboration_tools_follow_unfollow($entity) {
  global $user;

  list ($following, $reasons) = ma_collaboration_tools_get_following_status_and_reasons($entity, $user->uid);

  // Create output.
  $output = '';
  if ($following) {
    $output .= l('<button class="btn btn-default">UnFollow</button>', 'node/' . $entity->nid . '/unfollow', ['html' => TRUE]);
    $output .= '<div class="notifications-message">You are receiving notifications.</div>';
  }
  else {
    $output .= l('<button class="btn btn-default">Follow</button>', 'node/' . $entity->nid . '/follow', ['html' => TRUE]);
    $output .= '<div class="notifications-message">Follow to receive notifications.</div>';
  }

  // Popup text Following.
  if ($following) {
    $popup_text = '<p class="notification-popup-reasons-header">You are receiving notifications on this item because:</p>';
  }
  else {
    $popup_text = '<p class="notification-popup-reasons-header">You are not receiving notifications on this item because:</p>';
  }
  $popup_text .= $reasons;

  if ($following) {
    // Popup text node notification frequency form.
    $def_freq = isset($user->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $user->field_notifications_freq_def['und'][0]['value'] : 'right away';
    $node_freq = ma_collaboration_tools_get_user_node_notification_frequency($entity, $user);
    $form = drupal_get_form('ma_collaboration_tools_notification_frequency_node_' . $entity->nid, $entity->nid, $def_freq, $node_freq);
    $popup_text .= drupal_render($form);
  }

  // Add link to Following view.
  $popup_text .= '<span class="link-to-following-view">' . l('See all content you are following.', '/user/' . $user->uid . '/following') . '</span>';

  // Generate the popup
  require_once drupal_get_path('module', 'popup') . '/includes/popup.api.inc';
  $popup_attributes = array (
    'style' => 'White',
    'origin' => 'top-left',
    'expand' => 'top-left',
    'width' => '400',
    'class' => 'follow-unfollow-popup',
    // 'activate' => 'click', 'close' => 1, // uncomment this to tweak CSS in the inspector
  );
  $output .= popup_element('Details.', $popup_text, $popup_attributes);

  return $output;

}


/**
 * Helper function for Following view to show the default notification frequency form in the header.
 */
function ma_collaboration_tools_show_default_notification_frequency_form($view) {
  global $user;
  if ($view->args[0] == $user->uid) {
    $form = drupal_get_form('ma_collaboration_tools_notification_frequency_default');
    return drupal_render($form);
  }
}

/**
 * Helper function for Following view to show Unfollow button.
 */
function ma_collaboration_tools_show_unfollow_button_in_view($view, $data) {
  global $user;
  if ($view->args[0] == $user->uid) {
    return l('<button class="btn btn-default">UnFollow</button>', 'node/' . $data->nid . '/unfollow', [
      'html' => TRUE,
      'query' => drupal_get_destination()
    ]);
  }
}

/**
 * Helper function for Following view to show the Following reasons.
 */
function ma_collaboration_tools_show_following_reasons($view, $data) {
  list ($following, $reasons) = ma_collaboration_tools_get_following_status_and_reasons($data->_field_data['nid']['entity'], $view->args[0]);
  return $reasons;
}

/**
 * Helper function for Following view to show the per-node notification frequency form.
 */
function ma_collaboration_tools_generate_notication_frequency_form($view, $data) {
  global $user;
  if ($view->args[0] == $user->uid) {
    $viewed_user = user_load($view->args[0]);
    $entity = $data->_field_data['nid']['entity'];
    $def_freq = isset($user->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $viewed_user->field_notifications_freq_def['und'][0]['value'] : 'right away';
    $node_freq = ma_collaboration_tools_get_user_node_notification_frequency($entity, $viewed_user);
    $form = drupal_get_form('ma_collaboration_tools_notification_frequency_node_' . $entity->nid, $entity->nid, $def_freq, $node_freq);
    return drupal_render($form);
  }
}

/**
 * Returns if a given user is following a given node and why. Called from a few different places, including the Following view.
 */
function ma_collaboration_tools_get_following_status_and_reasons($entity, $uid) {

  $reasons = [];

  // Individually following
  if (isset($entity->field_following_users[LANGUAGE_NONE])) {
    foreach ($entity->field_following_users[LANGUAGE_NONE] AS $following_user) {
      if ($uid == $following_user['target_id']) {
        $following = TRUE;
        $reasons[] = 'you have individually followed this item';
        break;
      }
    }
  }

  // Following by protocol
  $following_by_protocol = [];
  if (isset($entity->field_following_protocols[LANGUAGE_NONE])) {
    foreach ($entity->field_following_protocols[LANGUAGE_NONE] AS $following_protocol) {
      if (og_is_member('node', $following_protocol['target_id'], 'user', $uid)) {
        $following_protocol_node = node_load ($following_protocol['target_id']);
        $following_by_protocol[] = $following_protocol_node->title;
        $following = TRUE;
      }
    }
  }

  // Individually unfollowing
  if (count($following_by_protocol)) {
    $reasons[] = 'you are a member of: ' . implode(', ', $following_by_protocol);
    if (isset($entity->field_un_following_users[LANGUAGE_NONE])) {
      foreach ($entity->field_un_following_users[LANGUAGE_NONE] AS $unfollowing_user) {
        if ($uid == $unfollowing_user['target_id']) {
          $following = FALSE;
          $reasons[] = 'you have individually unfollowed this item';
          break;
        }
      }
    }
  }
  // Has no explicitly followed, followed by group, or unfollowed.
  if (!isset($following)) {
    $following = FALSE;
    $reasons[] = 'you have never followed this item';

  }

  // Build reasons into a list, even if just one.
  $reasons = theme_item_list([
    'items' => $reasons,
    'title' => '',
    'type' => 'ul',
    'attributes' => []
  ]);

  // Return results.
  return [$following, $reasons];

}


/**
 * Implementation of hook_menu().
 */
function ma_collaboration_tools_menu() {

  $items['node/%node/follow'] = array(
    'page callback' => 'ma_collaboration_tools_follow_unfollow_process',
    'page arguments' => array(1, 'follow'),
    'access callback' => TRUE,
  );

  $items['node/%node/unfollow'] = array(
    'page callback' => 'ma_collaboration_tools_follow_unfollow_process',
    'page arguments' => array(1, 'unfollow'),
    'access callback' => TRUE,
  );

  $items['user/%user/following'] = array(
    'title' => 'Following',
    'page callback' => 'ma_collaboration_tools_following_view',
    'page arguments' => array(1),
    'access callback' => 'ma_collaboration_tools_following_view_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Callback to process the user clicking the follow or unfollow button.
 */
function ma_collaboration_tools_follow_unfollow_process($node, $op) {
  global $user;
  $nw = entity_metadata_wrapper ('node', $node);
  if ($op=='follow') {
    $nw->field_following_users[] = $user->uid;
    $new_unfollowing_users = [];
    $unfollowing_users = $nw->field_un_following_users->value();
    foreach ($unfollowing_users as $unfollowing_user) {
      if ($unfollowing_user->uid <> $user->uid) {
        $new_unfollowing_users[] = $unfollowing_user->uid;
      }
    }
    $nw->field_un_following_users->set($new_unfollowing_users);
  }
  else {
    $nw->field_un_following_users[] = $user->uid;
    $new_following_users = [];
    $following_users = $nw->field_un_following_users->value();
    foreach ($following_users as $following_user) {
      if ($following_user->uid <> $user->uid) {
        $new_following_users[] = $following_user->uid;
      }
    }
    $nw->field_following_users->set($new_following_users);
  }
  $nw->save();
  drupal_goto('node/' . $node->nid);
}

/**
 * Access callback; Determine if  user can view the Following tab on a given profile page.
 */
function ma_collaboration_tools_following_view_access($account) {
  global $user;
  // Can view if own profile page
  if ($user->uid == $account->uid) {
    return TRUE;
  }
  // Can view if admin or Mukurtu admin
  $admin = user_role_load_by_name('administrator');
  $mukurtuadmin = user_role_load_by_name('Mukurtu Administrator');
  if (user_has_role($admin->rid) || user_has_role($mukurtuadmin->rid)) {
    return TRUE;
  }
}

/**
 * Page callback; Call a view to show what the the user's Followings.
 */
function ma_collaboration_tools_following_view($account) {
  $view = views_get_view('mukurtu_collab_subscriptions');
  $view->set_arguments(array($account->uid));
  return $view->preview();
}

/**
 * Implements hook_views_post_execute.
 */
function ma_collaboration_tools_views_post_execute(&$view) {

  // Filter down the Following view. Views UI could not handle this, so we are doing it here.
  // It would be better to do this in a views query alter so that pagers could work (as now there is no paging),
  // plus more efficient, but I do not think it is possible. If this becomes slow then will need to set a hidden field
  // on the child collab nodes which contains following lists of users which can be queried.
  if ($view->name == "mukurtu_collab_subscriptions") {
    $uid = $view->args[0];
    foreach ($view->result as $i => $row) {
      list ($following, $reasons) = ma_collaboration_tools_get_following_status_and_reasons(node_load ($row->nid), $uid);
      if (!$following) {
       unset ($view->result[$i]);
      }
    }
  }
}

/**
 * Notification default frequency form (header of the Following view).
 */
function ma_collaboration_tools_notification_frequency_default($form, &$form_state) {
  $account = user_load(arg(1));
  $def_val = isset($account->field_notifications_freq_def[LANGUAGE_NONE][0]['value']) ? $account->field_notifications_freq_def['und'][0]['value'] : 'right away';
  global $user;
  $form = [
    'notification_frequency_default' => [
      '#type' => 'select',
      '#title' => t('Notification Frequency Default: '),
      '#options' => field_info_field('field_notifications_freq_def')['settings']['allowed_values'],
      '#default_value' => $def_val,
      '#disabled' => $user->uid <> $account->uid ? TRUE : FALSE,
      '#attributes' => [
        'onChange' => 'this.form.submit();',
      ],
    ],
    'submit' => [
      '#type' => 'submit',
    ],
  ];
  return $form;
}

/**
 * Submit handler for the notification default frequency sets the value on the user object.
 */
function ma_collaboration_tools_notification_frequency_default_submit ($form, &$form_state) {
  $account = user_load(arg(1));
  $existing_freq =& $account->field_notifications_freq_def[LANGUAGE_NONE][0]['value'];
  $new_freq = $form_state['values']['notification_frequency_default'];
  if ($existing_freq <> $new_freq) {
    $existing_freq = $new_freq;
    user_save($account);
  }
}

/**
 * Get the notification frequency for a given node and user.
 */
function ma_collaboration_tools_get_user_node_notification_frequency($node, $user) {
  if (isset($node->field_custom_notification_freq[LANGUAGE_NONE])) {
    foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $custom_frequency) {
      if ($custom_frequency['first'] == $user->uid) {
        return $custom_frequency['second'];
      }
    }
  }
}

/**
 * Notification node frequency form (in the node frequency popup as well as a column in the Following view).
 */
function ma_collaboration_tools_notification_frequency_node($form, &$form_state, $nid, $def_freq, $node_freq) {

  $options = ['use default' => 'Use Default (' . ucwords($def_freq) . ')'] + field_info_field('field_notifications_freq_def')['settings']['allowed_values'];
  $form = [
    'notification_frequency_node' => [
      '#type' => 'select',
      '#title' => t('Notification frequency: '),
      '#options' => $options,
      '#default_value' => isset($node_freq) ? $node_freq : 'use default',
      '#attributes' => [
        'onChange' => 'this.form.submit();',
      ],
    ],
    'nid' => [
      '#type' => 'value',
      '#value' => $nid,
    ],
    'submit' => [
      '#type' => 'submit',
    ],
  ];
  return $form;
}

/**
 * Submit handler for the notification frequency sets the value on the node for the user, or unsets it if using default.
 */
function ma_collaboration_tools_notification_frequency_node_submit ($form, &$form_state) {
  global $user;
  $val = $form_state['values']['notification_frequency_node'];
  $node = node_load ($form_state['values']['nid']);
  if ($val == 'use default') {
    foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $i => $custom_frequency) {
      if ($custom_frequency['first'] == $user->uid) {
        unset ($node->field_custom_notification_freq[LANGUAGE_NONE][$i]);
        node_save($node);
        return;
      }
    }
  }
  else {
    if (isset($node->field_custom_notification_freq[LANGUAGE_NONE])) {
      foreach ($node->field_custom_notification_freq[LANGUAGE_NONE] as $i => $custom_frequency) {
        if ($custom_frequency['first'] == $user->uid) {
          unset ($node->field_custom_notification_freq[LANGUAGE_NONE][$i]);
        }
      }
    }
    $node->field_custom_notification_freq[LANGUAGE_NONE][] = [
      'first' => $user->uid,
      'second' => $val,
    ];
    node_save($node);
  }
}

/**
 * Implementation of hook_forms()
 *
 * This is required because we are using the same form multiple times on the (Following) page. This allows for multiple form IDs calling the same form definition.
 */
function ma_collaboration_tools_forms($form_id, $args) {
  $forms = [];
  if (strpos($form_id, 'ma_collaboration_tools_notification_frequency_node_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'ma_collaboration_tools_notification_frequency_node',
    );
  }
  return $forms;
}
