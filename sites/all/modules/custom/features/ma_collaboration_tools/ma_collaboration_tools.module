<?php
/**
 * @file
 * Code for the Mukurtu Collaboration Tools feature.
 */

include_once 'ma_collaboration_tools.features.inc';

/**
 * Implements hook_page_alter().
 *
 * When viewing a CP, if there are section pages for the CP that the user has view rights to, then show them as tabs, with the CP itself in the first tab.
 */
function ma_collaboration_tools_page_alter(&$data) {

  if (isset($data['content']['system_main']['nodes']) && !isset($data['content']['system_main']['term_heading']['term'])) {

    $array_keys = array_keys($data['content']['system_main']['nodes']);
    $cp_node = $data['content']['system_main']['nodes'][array_shift($array_keys)]["#node"];
    if ($cp_node && $cp_node->type == 'cultural_protocol_group') {
      $nids = element_children($data['content']['system_main']['nodes']);
      $nid = $nids[0];

      // Get all section pages referencing that are in this CP.
      $query = new EntityFieldQuery();
      $result = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', ma_collaboration_tools_cp_section_node_types(), 'IN')
        ->propertyCondition('status', NODE_PUBLISHED) // or else it will retrieve node references for deleted DH items
        ->fieldCondition('og_group_ref', 'target_id', $nid)
        ->execute();

      if (isset($result['node']) && count($result['node'])) {
        $tabs = [];
        $section_nodes = node_load_multiple(array_keys($result['node']));
        foreach ($section_nodes as $section_node) {
          if (node_access('view', $section_node)) { // Ensure user has view perms to this section page.
            $tabs[] = [
              'type' => 'node',
              'nid' => $section_node->nid,
              'view_mode' => 'full',
              'title' => $section_node->title,
              'hide_title' => 0,
            ];
          }
        }
        if (count($tabs)) {

          // Main CP tab
          $contents = '';

          // Add the CP local tasks within the tab content.
          // This is like what is being done in ma_digitalheritage_preprocess_node & ma_digitalheritage_community_record_local_tasks but with a lot less code.
          $local_tasks = menu_local_tasks()['tabs']['output'];
          if (count($local_tasks) > 1) {
            $local_tasks['#prefix'] = '<ul class="tabs--primary nav nav-tabs">';
            $local_tasks['#suffix'] = '</ul>';
            $contents .= drupal_render($local_tasks);
            // Set a flag to remove the CP local tasks from above the tabs, processed in ma_collaboration_tools_preprocess_page.
            $data['hide_node_local_tasks'] = 1;
          }

          // Add the CP node content to the first tab contents, and then build the first tab.
          $node_view = node_view($cp_node, 'full');
          $contents .= drupal_render($node_view);
          $tabs[] = [
            'contents' => $contents,
            'title' => 'Protocol',
            'hide_title' => 1,
            'weight' => -1,
          ];

          // Build the tabs object and render it as the output.
          $tab_settings = [
            'ajax' => 0,
            'default_tab' => 0,
            'title' => 'CP Tabs',
            'renderer' => 'quicktabs',
            'style' => 'Excel',
            'hide_empty_tabs' => 1,
          ];
          $built_tabs = quicktabs_build_quicktabs("community-record", $tab_settings, $tabs);
          $data['content']['system_main']['#markup'] = drupal_render($built_tabs);

        }
      }
    }
  }
}

/**
 * Helper function returns CP section node types
 */
function ma_collaboration_tools_cp_section_node_types() {
  return [
    'calendar',
    'discussion_space',
    'document_library',
  ];
}

/**
 * Implements hook_preprocess_page.
 */
function ma_collaboration_tools_preprocess_page(&$variables) {
  if(isset($variables['node']) && $variables['node']->type == 'cultural_protocol_group') {
    // If the local tasks are being displayed separately within the CP tab, then hide the default local tasks which appear above the tabs.
    if (isset($variables['page']['hide_node_local_tasks'])) {
      unset($variables['tabs']);
    }
  }
}

/**
 * Implements hook_node_view().
 */
function ma_collaboration_tools_node_view($node, $view_mode) {

  // Update the item privacy text on the Collab section pages node view, to make more sense in this context and to hide it if there is only one protocol.
  if ($view_mode == 'full' && in_array($node->type, ma_collaboration_tools_cp_section_node_types())) {
    if (count($node->content['og_group_ref'][0]['#items']) < 2) {
      unset($node->content['field_item_privacy_setting'][0]['#markup']);
    }
    else {
      if ($node->field_item_privacy_setting[LANGUAGE_NONE][0]['value'] == 'any') {
        $text = 'Item is shared with members that belong to ANY of the above Protocols.';
      }
      else {
        $text = 'Item is shared with members that belong to ALL the above Protocols.';
      }
      $node->content['field_item_privacy_setting'][0]['#markup'] = $text;
    }
  }

  if ($view_mode == 'full' && $node->type == 'event') {

    $date = &$node->content['field_oa_date'][0]['#markup'];

    // For events with a repeating date, add a field label "Next: " for the next event date. This provides info clarification, and makes the next date align with the repeating date description.
    if (strpos($date, '<div class="date-repeat-rule">') !== false) {
      $closing_div_pos = strpos ($date, '</div>') + 6;
      $rrdiv = substr($date, 0, $closing_div_pos);
      $rest = substr($date, $closing_div_pos);
      $date =$rrdiv  . '<div class="label-inline">Next:&nbsp;</div>' . $rest;
    }

  }
}

/**
 * Get a map of the section page type to its content page type.
 */
function ma_collaboration_tools_section_type_to_page_type_map() {
  return [
    'calendar' => 'event',
    'discussion_space' => 'oa_discussion_post',
    'document_library' => 'oa_wiki_page'
  ];
}

/**
 * DS custom field.
 *
 * Add content to collab section link.
 */
function ma_collaboration_tools_add_content_to_section_link($entity) {
  $target_type = ma_collaboration_tools_section_type_to_page_type_map()[$entity->type];
  $node_disp_name = node_type_get_names()[$target_type];
  $pronoun = 'a';
  if (in_array(strtolower($node_disp_name{0}), ['a','e','i','o','u'])) {
    $pronoun = 'an';
  }
  $target_type_path = str_replace('_', '-', $target_type);
  if (og_user_access_entity('create ' . $target_type . ' content', 'node', $entity)) {
    return l('Add ' . $pronoun . ' ' . $node_disp_name, 'node/add/' . $target_type_path . '/' . $entity->nid, [
      'query' => drupal_get_destination(),
    ]);
  }
}

/**
 * DS custom field.
 *
 * Edit collab section link.
 */
function ma_collaboration_tools_edit_collab_section_link($entity) {
  if (node_access('update', $entity)) {
    $node_disp_name = node_type_get_names()[$entity->type];
    return l('Edit ' . $node_disp_name, 'node/' . $entity->nid . '/edit');
  }
}


/**
 * Implements hook_node_presave().
 */
function ma_collaboration_tools_node_presave($node) {
  if (ma_cultural_protocol_node_type_is_collab_page($node->type)) {

    // Copy the protocol, community, and item sharing field values for the collab pages from their parent section.
    $collab_page_w = entity_metadata_wrapper('node', $node);
    $collab_section_w = entity_metadata_wrapper('node', $collab_page_w->{ma_collaboration_tools_get_collab_page_section_page_field_ref($node->type)}->value());
    $collab_page_w->field_item_privacy_setting->set($collab_section_w->field_item_privacy_setting->value());
    $protocols = $collab_section_w->og_group_ref->value();
    $protocol_nids = [];
    $community_nids = [];
    foreach ($protocols as $protocol) {
      $protocol_nids[] = $protocol->nid;
      $community_nids[] = $protocol->og_group_ref[LANGUAGE_NONE][0]['target_id'];
    }
    if (count($protocol_nids)) {
      $collab_page_w->og_group_ref->set(array_unique($protocol_nids));
      $collab_page_w->field_community_ref->set(array_unique($community_nids));
    }

  }
}

/**
 * Helper function to get the collab page entity ref to its parent section field name.
 */
function ma_collaboration_tools_get_collab_page_section_page_field_ref($collab_page_node_type) {
  $field_map = [
    'event' => 'field_event_calendar_section',
    'oa_discussion_post' => '',
    'oa_wiki_page' => '',
  ];
  return $field_map[$collab_page_node_type];
}

/**
 *  Implements hook_form_alter().
 */
function ma_collaboration_tools_form_alter(&$form, &$form_state, $form_id) {

  // On Collab Pages (not collab section)
  $node_type = str_replace('_node_form', '', $form_id, $count);
  if ($count && ma_cultural_protocol_node_type_is_collab_page($node_type)) {

    // Adding a new collab page.
    if (is_null($form['nid']['#value'])) {

      // Prepopulate the reference to the section page with the argument from the URL.
      if (is_numeric(arg(3))) {
        $ref_field = ma_collaboration_tools_get_collab_page_section_page_field_ref($node_type);
        $form[$ref_field][LANGUAGE_NONE]['#value'] = arg(3);
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * Taken from OA.
 */
function ma_collaboration_tools_field_formatter_info() {
  return array(
    'events_date_formatter' => array(
      'label' => t('Open Atrium Date Formatter'),
      'field types' => array('datestamp'),
    ),
  );
}


/**
 * Implements hook_field_formatter_view().
 *
 * Taken from OA.
 */
function ma_collaboration_tools_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  if ($display['type'] == 'events_date_formatter') {

    $event_info = ma_collaboration_tools_find_next_event($items);
    $event = $event_info['event'];

    // Create Date objects from item values.
    $timezone_object = date_default_timezone_object();

    $start_date = new DateObject($event['value'], $event['timezone_db'], DATE_FORMAT_UNIX);
    $start_date->setTimezone($timezone_object);

    $end_date = new DateObject($event['value2'], $event['timezone_db'], DATE_FORMAT_UNIX);
    $end_date->setTimezone($timezone_object);

    // Create an array of month / day information for ease of use.
    $dates = array(
      'start' => array(
        'day' => date_format_date($start_date, 'custom', 'd'),
        'month' => date_format_date($start_date, 'custom', 'M'),
      ),
      'end' => array(
        'day' => date_format_date($end_date, 'custom', 'd'),
        'month' => date_format_date($end_date, 'custom', 'M'),
      ),
    );

    // For now always use the start date. We may add multi-day event to the
    // widget at some point in the future.
    $day = $dates['start']['day'];
    $month = $dates['start']['month'];
    $element[0] = array(
      '#markup' => theme('event_date', array('month' => $month, 'day' => $day)),
    );
  }
  return $element;
}

/**
 * Find the next upcoming event or the last event in a series.
 *
 * @param  array $items
 *   An array of dates attached to a field.
 * @return array
 *   An array, keyed by delta and event.
 *
 * Taken from OA.
 */
function ma_collaboration_tools_find_next_event($items) {
  // Set some base params we'll need.
  $now = time();
  $event = NULL;
  $event_delta = NULL;
  $next_event = NULL;
  $last_event = NULL;
  $next_event_delta = NULL;
  $last_event_delta = NULL;
  $diff = 0;

  // Loop through all events.
  foreach ($items as $delta => $date) {
    // If event is a future date.
    if ($date['value'] >= $now) {
      // That happens before the last found future event
      if ($diff == 0 || ($date['value'] - $now) < $diff) {
        // Set it as the currently found next event, and update the difference.
        $diff = $date['value'] - $now;
        $next_event = $date;
        $next_event_delta = 0;
      }
    }
    // Determine if this is the last event in the series.
    else if (empty($last_event) || ($date['value'] > $last_event['value'])) {
      $last_event = $date;
      $last_event_delta = $delta;
    }
  }

  // If there is no future event we'll use the last occurrence.
  if (empty($next_event)) {
    $event = $last_event;
    $event_delta = $last_event_delta;
  }
  else {
    $event = $next_event;
    $event_delta = $next_event_delta;
  }

  return array(
    'delta' => $event_delta,
    'event' => $event,
  );
}

/**
 * Implements hook_theme()
 *
 * Taken from OA. Simplified.
 */
function ma_collaboration_tools_theme() {

  $theme = array(
    'event_date' => array(
      'template' => 'event-date',
      'path' => drupal_get_path('module', 'ma_collaboration_tools') . '/templates',
      'variables' => array(
        'month' => NULL,
        'day' => NULL,
      ),
    ),
  );
  return $theme;
}


/**
 * Custom follow/unfollow field.
 */
function ma_collaboration_tools_follow_unfollow($entity) {
  global $user;

  $reason = [];

  // Individually following
  if (isset($entity->field_following_users[LANGUAGE_NONE])) {
    foreach ($entity->field_following_users[LANGUAGE_NONE] AS $following_user) {
      if ($user->uid == $following_user['target_id']) {
        $following = TRUE;
        $reason[] = 'Individually following';
        break;
      }
    }
  }

  // Following by protocol
  $following_by_protocol = [];
  if (isset($entity->field_following_protocols[LANGUAGE_NONE])) {
    foreach ($entity->field_following_protocols[LANGUAGE_NONE] AS $following_protocol) {
      if (og_is_member('node', $following_protocol['target_id'])) {
        $following_by_protocol[] = $following_protocol['entity']->title;
        $following = TRUE;
      }
    }
  }

  // Individually unfollowing
  if (count($following_by_protocol)) {
    $reason[] = 'Member of: ' . implode(', ', $following_by_protocol);
    if (isset($entity->field_un_following_users[LANGUAGE_NONE])) {
      foreach ($entity->field_un_following_users[LANGUAGE_NONE] AS $following_user) {
        if ($user->uid == $following_user->target_id) {
          $following = FALSE;
          $reason[] = 'Individually unfollowing';
          break;
        }
      }
    }
  }
  // Has no explicitly followed, followed by group, or unfollowed.
  if (is_null($following)) {
    $following = FALSE;
    $reason[] = 'Never followed';
  }

  // Create output.
  if ($following) {
    $output = l('<button class="btn btn-default">UnFollow</button>', 'node/' . $entity->nid . '/unfollow', ['html' => TRUE]);
    $link_text = "You are receiving notifications.";
  }
  else {
    $output = l('<button class="btn btn-default">Follow</button>', 'node/' . $entity->nid . '/follow', ['html' => TRUE]);
    $link_text = "Follow to receive notifications.";
  }
  $popup_output = implode('<br />', $reason);
  require_once drupal_get_path('module', 'popup') . '/includes/popup.api.inc';
  $popup_attributes = array (
    'style' => 'Bent white',
    'origin' => 'top-left',
    'expand' => 'top-left',
    // 'activate' => 'click', 'close' => 1, // uncomment this to tweak CSS in the inspector
  );
  $output .= popup_element($link_text, $popup_output, $popup_attributes);

  return $output;

}

/**
 * Implementation of hook_menu().
 */
function ma_collaboration_tools_menu() {
  $items['node/%node/follow'] = array(
    'page callback' => 'ma_collaboration_tools_follow',
    'page arguments' => array(1),
    'access callback' => TRUE,
  );
  $items['node/%node/unfollow'] = array(
    'page callback' => 'ma_collaboration_tools_unfollow',
    'page arguments' => array(1),
    'access callback' => TRUE,
  );
  return $items;
}

function ma_collaboration_tools_unfollow($node) {
  dpm ($node->nid);
  drupal_goto('node/' . $node->nid);
}
function ma_collaboration_tools_follow($node) {
  dpm ($node->nid);
  drupal_goto('node/' . $node->nid);
}
